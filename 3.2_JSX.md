## Introduction au JSX

### Qu'est-ce que JSX ?
JSX (*JavaScript XML*) est une extension de syntaxe pour JavaScript utilisÃ©e avec **React**. C'est du Javascript classique dans lequel on peut ajouter
une sorte de structure HTML. Cependant, il est important de comprendre que le `JSX` n'est pas compris directement par les navigateurs web. `JSX` est une syntaxe qui doit Ãªtre compilÃ©e en JavaScript classique pour pouvoir Ãªtre interprÃ©tÃ© par les navigateurs.

### Pourquoi utiliser JSX ?
âœ… **LisibilitÃ© amÃ©liorÃ©e** : le code est plus intuitif quâ€™avec `React.createElement`.  
âœ… **Syntaxe proche du HTML** : facilite l'intÃ©gration avec des dÃ©veloppeurs front-end.  
âœ… **Performances optimisÃ©es** : React compile JSX en code JavaScript optimisÃ©.


### Qu'est-ce qu'il faut comprendre par `LisibilitÃ© amÃ©liorÃ©e` ?
Revenons au message `Hello World ğŸš€ğŸš€ğŸš€` que nous avions affichÃ© sur notre interface et on verra comment l'afficher mais autrement.
 
* `createElement` permet de crÃ©er un Ã©lÃ©ment `React` et attend les valeurs suivantes : `createElement(type, props, ...children)`
 * `type` doit Ãªtre un composant React valide. Il peut s'agir d'un nom de balise HTML ou de **composant React**
 * `props` : un objet ou `null` 
 * `children` : zÃ©ro ou plusieurs noeuds enfants.
 
```jsx
import {createElement } from 'react';

function App() {
  return createElement(
    'h1',
    null,
    'Hello World ğŸš€ğŸš€ğŸš€'
  )
}

export default App
```

```jsx
import { createElement } from 'react';

function App() {
  return createElement(
    'h1',
    {className: 'big-title'}, //Ajoute une classe `big-title` Ã  notre `h1`. Cela peut se voir dans la console
    'Hello World ğŸš€ğŸš€ğŸš€'
  )
}

export default App
```

```jsx
import {createElement } from 'react';

function App() {
  return createElement(
    'div',
    {className: 'big-div'},
    createElement(
      'h1',
      {className: 'big-title'},
      'Hello world ğŸš€ğŸš€ğŸš€'
    ), //Ajoute un titre de premier ordre avec le contenu `Hello world ğŸš€ğŸš€ğŸš€` et une classe `big-title`
    createElement(
      'p',
      {className: 'big-text'},
      'Ceci est un texte descriptif'
    ), //Ajoute un paragraphe avec le contenu `Ceci est un texte descriptif` et une classe `big-text`
  );
}

export default App
```
### Qu'est-ce que cela donnerait avec le HTML ?

```jsx
function App() {
  const firstElement = <h1>Hello World ğŸš€ğŸš€ğŸš€</h1>;

  return firstElement
}

export default App
```


```jsx

function App() {
const firstElement = <h1 className="big-title">Hello World ğŸš€ğŸš€ğŸš€</h1>;

return firstElement;
}


export default App
```


```jsx

function App() {

const firstElement = (
  <div>
    <h1 className="big-title">Hello World ğŸš€ğŸš€ğŸš€</h1>
    <p className="'big-text'">Ceci est un texte descriptif</p>
  </div>
);

return firstElement;
}


export default App
```

### Petites subtilitÃ©s avec le JSX

## 1. Pour attribuer une classe Ã  un Ã©lÃ©ment, on utilise `className` au lieu de `class` : 

```jsx
function App() {
const firstElement = <h1 class="big-title">Hello World ğŸš€ğŸš€ğŸš€</h1>;

return firstElement;
}
export default App
```

Si vous ouvrez la console, vous pourrez remarquer l'erreur suivante :  

![Erreur par utilisation de class](./img/erreur_class.PNG 'Erreur par utilisation de class')

En JavaScript, `class` est un mot-clÃ© rÃ©servÃ©. Il est utilisÃ© pour dÃ©finir des classes dans la programmation orientÃ©e objet `(ex. class MyClass {})`. ConsidÃ©rant le fait que `JSX` est un mÃ©lange de `JavaScript` et de `HTML`, `React` a donc trouvÃ© judicieux pour Ã©viter un conflit entre l'attribut **HTML** `class` et le mot-clÃ© **JavaScript**, d'utiliser `className` Ã  la place.

## 2. `htmlFor` au lieu de `for`

```jsx
function App() {
  return (
    <div>
      <label for="username">Username</label>
      <input id="username" type="text" />
    </div>
  );
}

```

Comme pour le cas prÃ©cÃ©dent, on a une erreur dans la console : 

![Erreur par utilisation de for](./img/erreur_for.PNG 'Erreur par utilisation de for')

Il est donc conseillÃ© d'utilser `htmlFor` car `for` est un mot-clÃ© rÃ©servÃ© en JavaScript (utilisÃ© pour les boucles, par exemple).

```jsx
function App() {
  return (
    <div>
      <label htmlFor="username">Username</label>
      <input id="username" type="text" />
    </div>
  );
}

```
## 3. Expression `JSX` multiligne

Une expression `JSX` qui s'Ã©tend sur plusieurs lignes doit Ãªtre entourÃ©e de parenthÃ¨ses : `(` et `)`. 

* Pourquoi utiliser des parenthÃ¨ses pour du JSX multiligne ?
   * **Faciliter la lisibilitÃ©** : Les parenthÃ¨ses aident Ã  rendre le code plus lisible, surtout lorsque le JSX est long et rÃ©parti sur plusieurs lignes. Cela permet de mieux comprendre oÃ¹ commence et oÃ¹ finit un bloc JSX.
   * **RÃ©duire les erreurs avec des retours Ã  la ligne** : Si vous ne mettez pas de parenthÃ¨ses, un retour Ã  la ligne peut Ãªtre mal interprÃ©tÃ© par le compilateur JavaScript. Le compilateur pourrait penser que la ligne suivante est une nouvelle expression, ce qui peut gÃ©nÃ©rer une erreur.

## 4. Ã‰lÃ©ments JSX imbriquÃ©s

Le code ci-dessus va gÃ©nÃ©rer une erreur.
```jsx

function App() {

const firstElement = (
 
    <h1 className="big-title">Hello World ğŸš€ğŸš€ğŸš€</h1>
    <p className="'big-text'">Ceci est un texte descriptif</p>
 
);

return firstElement;
}


export default App

```

Pour que le code soit compilÃ©, une expression `JSX` doit contenir exactement un Ã©lÃ©ment externe. 

```jsx

function App() {

const firstElement = (
  <div>
    <h1 className="big-title">Hello World ğŸš€ğŸš€ğŸš€</h1>
    <p className="'big-text'">Ceci est un texte descriptif</p>
  </div>
);

return firstElement;
}


export default App

```
La structure du code ci-dessus dans la console est la suivante : 

![structure code](./img/structure_code.PNG 'Element externe parent structure')

Si nous ne voulons pas que l'Ã©lÃ©ment parent soit considÃ©rÃ© dans notre architecture, nous pouvons utiliser 

```jsx

function App() {

const firstElement = (
  <> 
    <h1 className="big-title">Hello World ğŸš€ğŸš€ğŸš€</h1>
    <p className="'big-text'">Ceci est un texte descriptif</p>
  </> 
  // ou <Fragment></Fragment>
);

return firstElement;
}


export default App

```
Dans React, lorsque tu souhaites retourner plusieurs Ã©lÃ©ments depuis un composant sans ajouter de balise inutile dans le DOM (comme une div), tu peux utiliser la balise `Fragment`. Elle permet de regrouper plusieurs Ã©lÃ©ments sans crÃ©er de nÅ“ud supplÃ©mentaire dans le DOM final.

la structure correspondante est la suivante :<br> 
![Structure avec balise fragment](./img/struture_code_sans_parent.PNG 'Utilisation de Fragment pour englober le code')

## 5. IntÃ©gration de JavaScript dans `JSX`
Une des grandes forces de `JSX` est sa capacitÃ© Ã  intÃ©grer du `JavaScript` directement Ã  l'intÃ©rieur du code HTML. On peut intÃ©grer des expressions `JavaScript` en les entourant de `{ }`. Cela permet dâ€™insÃ©rer des variables, des appels de fonctions, des opÃ©rations mathÃ©matiques, des conditions, etc. Voici quelques exemples :

```jsx
function App() {
  const message = "Hello World ğŸš€";

  return <h1>{message}</h1>;  // Affiche "Hello World ğŸš€"
}

export default App;

```

**Exemple 2 : Effectuer des calculs dans JSX**

Les expressions mathÃ©matiques peuvent aussi Ãªtre intÃ©grÃ©es dans JSX.

```jsx
function App() {
  const num1 = 10;
  const num2 = 5;

  return <h1>La somme est : {num1 + num2}</h1>;  // Affiche "La somme est : 15"
}

export default App;
```


**Exemple 3 : Utiliser des expressions conditionnelles**

 
Il est possible d'utiliser des opÃ©rateurs conditionnels dans JSX pour afficher du contenu en fonction dâ€™une condition.

1. Syntaxe ternaire 

```jsx
function App() {
  const isLoggedIn = true;

  return <h1>{isLoggedIn ? 'Bienvenue, utilisateur !' : 'Veuillez vous connecter'}</h1>;
}

export default App;

```
2. Rendu conditionnel avec `&&` **(ET logique)** dans `JSX`

L'opÃ©rateur `&&` en JavaScript renvoie la premiÃ¨re valeur si elle est falsy (comme `false`, `null`, `undefined`, `0`, etc.), et la seconde si la premiÃ¨re est truthy. Cela permet d'utiliser && pour contrÃ´ler l'affichage d'un Ã©lÃ©ment dans `JSX`.

Lorsque tu utilises `&&` dans `JSX`, le deuxiÃ¨me opÃ©rande (l'Ã©lÃ©ment `JSX` que tu veux afficher) sera rendu uniquement si la premiÃ¨re condition (le premier opÃ©rande) est truthy.

**Exemple de base avec `&&`**

```jsx
function App() {
  const isLoggedIn = true;

  return (
    <div>
      {isLoggedIn && <h1>Bienvenue, utilisateur !</h1>}
    </div>
  );
}

export default App;

```
**Exemple avec un contenu conditionnel plus complexe**

```jsx
function App() {
  const isLoggedIn = false;
  const username = 'Alice';

  return (
    <div>
      {isLoggedIn && <h1>Bienvenue, {username}!</h1>}
      {!isLoggedIn && <h1>Veuillez vous connecter</h1>}
    </div>
  );
}

export default App;

```

**Exemple 4 : Appel d'une fonction dans JSX**

```jsx
function getGreeting(name) {
  return `Bonjour, ${name}!`;
}

function App() {
  return <h1>{getGreeting("Alice")}</h1>;  // Affiche "Bonjour, Alice!"
}

export default App;

```

**Exemple 5 : Rendu de liste**

En `React`, on utilise `.map()` pour itÃ©rer sur un tableau d'Ã©lÃ©ments et retourner un tableau de composants JSX. Chaque Ã©lÃ©ment de la liste peut Ãªtre transformÃ© en un Ã©lÃ©ment `React`, comme un `div`, `li`, ou un composant personnalisÃ©.

Exemple simple avec `.map()`

```jsx
function App() {
  const users = ['Alice', 'Bob', 'Charlie', 'David'];

  return (
    <ul>
      {users.map((user, index) => (
        <li key={index}>{user}</li>
      ))}
    </ul>
  );
}

export default App;

```

Pourquoi utiliser la propriÃ©tÃ© key ?

Lorsque tu gÃ©nÃ¨res des Ã©lÃ©ments de liste Ã  l'aide de `.map()`, il est essentiel d'ajouter une propriÃ©tÃ© `key` Ã  chaque Ã©lÃ©ment. Cela permet Ã  `React` d'identifier chaque Ã©lÃ©ment de maniÃ¨re unique pour optimiser les performances lors du rendu et de la mise Ã  jour du DOM.

Utilisation de `.map()` pour des composants personnalisÃ©s

```jsx
function User({ name }) {
  return <li>{name}</li>;
}

function App() {
  const users = ['Alice', 'Bob', 'Charlie', 'David'];

  return (
    <ul>
      {users.map((user, index) => (
        <User key={index} name={user} />
      ))}
    </ul>
  );
}

export default App;

```

Cas pratique : Affichage d'une liste d'objets avec `.map()`

```jsx
function Product({ name, price, description }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>{description}</p>
      <p>Prix: ${price}</p>
    </div>
  );
}

function App() {
  const products = [
    { id: 1, name: 'Product 1', price: 29.99, description: 'Description de Product 1' },
    { id: 2, name: 'Product 2', price: 49.99, description: 'Description de Product 2' },
    { id: 3, name: 'Product 3', price: 19.99, description: 'Description de Product 3' },
  ];

  return (
    <div>
      {products.map((product) => (
        <Product key={product.id} name={product.name} price={product.price} description={product.description} />
      ))}
    </div>
  );
}

export default App;

```
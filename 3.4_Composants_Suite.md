### Les deux types de composants :

1. **Composants de classe** : Ce sont des classes qui √©tendent la classe `React.Component` et qui utilisent une m√©thode `render()` pour renvoyer du `JSX`. Ce type de composant est moins courant aujourd'hui, car les `Hooks` permettent de g√©rer l'√©tat et les effets dans les composants fonctionnels. 
 
Exemple :

```jsx
import React from 'react';

class Salut extends React.Component {
  render() {
    return <h1>Bonjour, {this.props.nom}!</h1>;
  }
}

```


2. **Composants fonctionnels** : Ce sont des fonctions JavaScript qui renvoient du JSX pour d√©crire l‚ÄôUI. Les composants fonctionnels sont souvent utilis√©s de nos jours en raison de leur simplicit√© et de leur facilit√© d‚Äôutilisation avec les hooks. 
   
Exemple :
 
```jsx
function Salut() {
  return <h1>Bonjour, Boss !</h1>;
}

```

Un composant fonctionnel, c'est trois parties essentielles : 
* le state (√©tats, donn√©es)
* comportements
* affichage (render) : rendu possbile via le mot cl√© `return`

### Premi√®res manipulations
Dans cette partie du cours, nous allons d√©couvrir notre premier `hook`, le `useState`.
Un `hook` est simplement une fonction qui vous permet d'utiliser des fonctionnalit√©s de React. 

1. D√©limittons par des commentaires les trois parties de notre composant
2. Ce qu'il faut savoir sur `useState`
Le `hook` `useState` est l'un des hooks les plus utilis√©s en `React`, et il permet de g√©rer l'√©tat d'un composant fonctionnel. Il retourne un tableau avec deux √©l√©ments.


```jsx
const [state, setState] = useState(initialState);
``` 
* `initialState` : La valeur initiale de l'√©tat. Cela peut √™tre une valeur primitive (comme un nombre ou une cha√Æne de caract√®res), un tableau, un objet, etc.

* `state` (l'√©tat actuel) : La variable qui contient la valeur actuelle de l'√©tat.

* `setState` (le setter d'√©tat) : La fonction qui permet de mettre √† jour l'√©tat.

Nous allons d√©finir un state, que nous allons **initialiser** √† `1`. Cette valeur sera r√©cup√©r√©e dans la variable `compteur`. Variable qu'on pourra assez facilement modifier gr√¢ce √† la fonction `setCompteur`.

1. *Projettons* (affichons) la variable compteur sur notre interface. 
2. Et si on jouait un peu ?! 
   * Ajoutons un bouton qui va nous permettre d'incr√©menter la valeur de notre variable `compteur`
   * Nous avons besoin de d√©finir un "comportement" pour rendre effective cette incr√©mentation. Par convention, nous appelerons ce "comportement" `handleClick`.
   * Avec l'√©couteur d'√©v√©nement `onClick` pour lier notre "comportement" au clique de notre bouton.
   * Rempla√ßons par `let` le mot cl√© ayant servi √† la d√©claration du tableau permette de r√©cup√©rer le return de notre `ustState`
   * Voil√† √† quoi doit ressembler notre comportement `handleClick` : 
```jsx
     const handleClick = () => {
    // alert("handleClick");
    console.log("compteur", compteur);
    compteur += 1;
    console.log("compteur", compteur);
  }
``` 
Dans la console, nous voyons bien que `compteur` est modifi√©e mais sans que cela n'impacte le rendu. Cela est d√ª au fait qu'on ne modifie **JAMAIS** un state directement. On utilise **TOUJOURS** son `setter` d√©di√©. En faisant ainsi, le `setter` va modifier la valeur du `state` auquel il est li√© mais cela aura pour cons√©quence de "pousser" le composant √† **REAGIR** en actualisant **AUTOMATIQUEMENT** l'affichage. 


```jsx
 const handleClick = () => {
    setCompteur(compteur + 1);
  }
```
   * Incr√©mentons maintenant notre `compteur` √† chaque clique du bouton ! Eur√™ka, mon code marche mainteant ‚úå‚úå‚úå‚úå

On ira plus loin avec notre application. Et si on mettait en place une calculatrice ?

* Supprimons le contenu de notre composant. le render doit contenir le code suivant : 
 
```jsx
  <div className="calculator">
      <div className="display"></div>
      <div className="buttons">
        <button >1</button>
        <button >2</button>
        <button >3</button>
        <button >+</button>
        <button >4</button>
        <button >5</button>
        <button >6</button>
        <button >-</button>
        <button >7</button>
        <button >8</button>
        <button >9</button>
        <button >*</button>
        <button >0</button>
        <button >C</button>
        <button >=</button>
        <button >/</button>
      </div>
    </div> 
``` 

* R√©cup√©rer le code css suivant pour mieux styliser notre calculatrice 

```css 
.calculator {
  width: 200px;
  margin: 50px auto;
  padding: 20px;
  border: 2px solid #000;
  border-radius: 10px;
  background-color: #f9f9f9;
}

.display {
  height: 90px;
  text-align: right;
  font-size: 20px;
  padding: 5px;
  background-color: #eaeaea;
  border: 1px solid #ccc;
}

.buttons button {
  width: 40px;
  height: 40px;
  font-size: 18px;
  margin: 5px;
  cursor: pointer;
  border: none;
  border-radius: 5px;
  background-color: #f1f1f1;
}

.buttons button:hover {
  background-color: #dcdcdc;
}
``` 

**√Ä l'heure actuelle, nous avons une calculatrice, mais elle ne remplit pas encore toutes ses fonctions attendues. Nous allons travailler sur son am√©lioration.**

Pour que la calculatrice fonctionne correctement, nous aurons besoin de :

* R√©cup√©rer chacune des valeurs sur lesquelles l'utilisateur clique.

* R√©cup√©rer l'op√©rateur choisi par l'utilisateur.

* Permettre de supprimer les valeurs saisies.
 
* Soumettre l'op√©ration pour effectuer le calcul.
 

  
#### 1. R√©cup√©rer chacune des valeurs sur lesquelles l'utilisateur clique (handleNumberClick)
#### 2. R√©cup√©rer l'op√©rateur choisi par l'utilisateur (handleOperatorClick)
#### 3. Permettre de supprimer les valeurs saisies (handleClear)
#### 4. Soumettre l'op√©ration pour effectuer le calcul (handleEqualClick)


Maintenant que la caulculatrice fonctionne, c'est bien beau tout cela mais on peut faire encore mieux. On va incr√©menter le niveau en modularisant le code. La structure de fichier que nous aurons √† la fin : 

```css
src/
‚îÇ
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ Button.jsx
‚îÇ   ‚îú‚îÄ‚îÄ Display.jsx
‚îÇ   ‚îî‚îÄ‚îÄ Calculator.jsx
‚îÇ
‚îî‚îÄ‚îÄ App.js

```
Cette partie nous permettra d'aborder les `props` en React.

##### Plan de modularisation
1. Cr√©er un composant `Button` :
   * Ce composant repr√©sentera un bouton.

   * Il recevra en props une `label` (le texte du bouton) et une fonction `onClick` qui sera ex√©cut√©e lorsque l'utilisateur clique dessus. 

2. Cr√©er un composant `Display` :

    * Ce composant affichera l'√©tat actuel de la calculatrice (les chiffres ou le r√©sultat). 

3.  Cr√©er un composant `Calculator` :

    * Ce composant va g√©rer l'√©tat (comme `operatorDeux`, `display`, etc.) et assembler les autres composants (`Button`, `Display`).


##### Exercice : 

**Pr√©sentation de "SnapShot"**

![Snapshot en image](./img/snapshot_image.PNG)

`SnapShot` est une application innovante qui permet aux utilisateurs de rechercher des images automatiquement gr√¢ce √† une API.

Elle facilite l'acc√®s √† une large biblioth√®que d'images en ligne, offrant une exp√©rience fluide et rapide pour trouver l'image id√©ale en quelques clics. Voici un exemple du r√©sultat final :


Pour commencer, r√©visons les concepts que nous avons abord√©s jusqu'ici. Vous allez r√©cup√©rer le dossier exo_1_images et l'utiliser dans un nouveau projet React que vous allez cr√©er, nomm√© SnapShot üòéüòéüòé.

En plus du composant principal qui affichera le titre (h1), vous devrez mettre en place deux autres composants :

* Un composant pour l'affichage des boutons.

* Un autre composant pour afficher les images li√©es au bouton s√©lectionn√©.

A vous de jouer 
## useReducer

En React, un `reducer` est une fonction qui gÃ¨re l'Ã©tat d'un composant ou d'une application en fonction des actions reÃ§ues. Il est souvent utilisÃ© avec le hook `useReducer` pour gÃ©rer des Ã©tats complexes. 
Voici un aperÃ§u de son utilisation :

**Structure d'un Reducer**
Un `reducer` est une fonction qui prend deux arguments :

 1. **Ã‰tat prÃ©cÃ©dent** : L'Ã©tat actuel que vous souhaitez mettre Ã  jour.
 2. **Action** : Un objet qui dÃ©crit le type d'action Ã  effectuer et Ã©ventuellement des donnÃ©es supplÃ©mentaires.
  
*La fonction retourne un nouvel Ã©tat.*  


```jsx
const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

const [state, dispatch] = useReducer(reducer, initialState);
```

   * `state` : lâ€™Ã©tat actuel (objet, tableau, etc.)

   * `dispatch(action)` : une fonction pour envoyer une action

   * `reducer(state, action)` : une fonction qui reÃ§oit lâ€™action et retourne un nouvel Ã©tat

   * `initialState` : lâ€™Ã©tat initial du composant

```jsx
<p>{state.count}</p>


<button onClick={() => dispatch({ type: 'increment' })}>+</button>
```

* Cas pratique avec notre calucltrice

Objectif de cette Ã©tape : **remplacer tous les `useState` liÃ©s au calcul** (saisie, secondValue, operator, result, error) par `useReducer`. 

âœ… Ã‰tape 1 â€” DÃ©finir lâ€™Ã©tat initial

Dans `Calculator.jsx`, au tout dÃ©but, ajoute :

```jsx
const initialState = {
  saisie: null,
  secondValue: null,
  operator: null,
  result: null,
  errorMessage: ""
};
```

âœ… Ã‰tape 2 â€” CrÃ©er la fonction `calculatorReducer`

Juste en dessous, ajoute :

```jsx
function calculatorReducer(state, action) {
  switch (action.type) {
    case 'ADD_DIGIT':
      if (!state.operator) {
        if (state.saisie?.length >= 10) return state;
        return {
          ...state,
          saisie: (state.saisie || "") + action.payload
        };
      } else {
        if (state.secondValue?.length >= 10) return state;
        return {
          ...state,
          secondValue: (state.secondValue || "") + action.payload
        };
      }

    case 'SET_OPERATOR':
      return { ...state, operator: action.payload };

    case 'CLEAR':
      return initialState;

    case 'SET_RESULT':
      return { ...state, result: action.payload };

    case 'SET_ERROR':
      return { ...state, errorMessage: action.payload };

    default:
      return state;
  }
}

```

Ce reducer va gÃ©rer toute la logique mÃ©tier : ajout de chiffres, opÃ©rateurs, rÃ©sultat, etc.

âœ… Ã‰tape 3 â€” Utiliser useReducer dans ton composant

Remplace les anciens `useState` :

```jsx
// âŒ Ã  supprimer
// const [saisie, setSaisie] = useState(null);
// const [secondValue, setSecondValue] = useState(null);
// const [operator, setOperator] = useState(null);
// const [result, setResult] = useState(null);
// const [errorMessage, setErrorMessage] = useState("");

const [state, dispatch] = React.useReducer(calculatorReducer, initialState);

```

âœ… Tu peux maintenant accÃ©der Ã  :

   * state.saisie

   * state.operator

   * state.secondValue

   * state.result

   * state.errorMessage

Il faudra aller Ã©tape par Ã©tape pour remplacer les setters utilisÃ©s prÃ©cÃ©demment par `dispatch`

ğŸ¯ Quand utiliser `useState` vs `useReducer`

| CritÃ¨re / Situation | âœ… **useState** | âœ… **useReducer** |
|:--|:--|:--|
| ğŸ“¦ Tu gÃ¨res **1 ou 2 valeurs simples** (ex: boolÃ©ens, texte, nombre) | âœ… Oui | âŒ Inutile |
| ğŸ§© Tu as **plusieurs Ã©tats** indÃ©pendants et simples | âœ… Oui | âŒ Pas nÃ©cessaire |
| ğŸ”— Tu as **plusieurs Ã©tats qui dÃ©pendent les uns des autres** | âŒ Difficile | âœ… IdÃ©al |
| ğŸ” Tu as **des transitions de logique** (ex: Ã©tapes, scÃ©narios) | âŒ Trop de `if` | âœ… Parfait |
| ğŸ§  Tu veux **garder la logique centralisÃ©e** | âŒ Impossible | âœ… `reducer()` clair |
| ğŸ” Tu veux **tester ou simuler les effets dâ€™une action** | âŒ Complexe | âœ… Facile Ã  tester |
| ğŸ§± Tu veux faire **grandir ton composant dans le temps** | âŒ Faible Ã©volutivitÃ© | âœ… Facile Ã  faire Ã©voluer |


<img src="./img/useState_vs_useReducer_comparatif.png" />

## props.children

En React, props.children reprÃ©sente **le contenu quâ€™on place Ã  lâ€™intÃ©rieur dâ€™un composant** lors de son utilisation.

Câ€™est ce qui permet Ã  un composant dâ€™Ãªtre "**conteneur**" ou "**wrapper**".

Exemple simple

Composant :

```jsx
function Boite(props) {
  return (
    <div className="boite">
      <h2>Contenu :</h2>
      <div>{props.children}</div>  {/* â† ici le contenu passe */}
    </div>
  );
}
```

Utilisation :

```jsx
<Boite>
  <p>Bonjour</p>
  <button>OK</button>
</Boite>

```

Ce que React voit rÃ©ellement :

```jsx
<div className="boite">
  <h2>Contenu :</h2>
  <div>
    <p>Bonjour</p>
    <button>OK</button>
  </div>
</div>

```
# ğŸ“š `useMemo`, `useCallback` et `React.memo` en React
---

## `useMemo` ou Le mÃ©moÃ¯sage de valeurs

### ğŸ” Ã€ quoi sert `useMemo` ?
`useMemo` sert Ã  mÃ©moriser une valeur qui est coÃ»teuse Ã  **recalculer**, ou **inutile Ã  recalculer** Ã  *chaque re-render*.

â¡ï¸ Il Ã©vite que cette valeur soit recalculÃ©e si *ses dÃ©pendances* ne changent pas.

ğŸ“¦ Syntaxe

```jsx
const memoizedValue = useMemo(() => computeSomething(), [dependency1, dependency2]);
```

### âœ… Situations typiques

| Situation                                              | Pourquoi `useMemo` ?                            |
| ------------------------------------------------------ | ----------------------------------------------- |
| Calcul intensif (ex: gros filtre, tri, somme)          | Ã‰vite de recalculer inutilement Ã  chaque render |
| DÃ©pendance Ã  une variable stable                       | Ne change que quand la variable change          |
| Passer une valeur stable Ã  un composant enfant (props) | Ã‰vite des re-renders inutiles                   |

### ğŸ¯ Exemple : Filtrage dâ€™une longue liste
nous allons crÃ©er un nouveau composant `UseMemo` qui sera rendu par `App`

ğŸ¯ Objectif
  * Tu as une liste dâ€™utilisateurs trÃ¨s longue

  * Tu peux filtrer cette liste en tapant dans un champ

  * Tu peux aussi cliquer sur un compteur qui nâ€™a rien Ã  voir avec le filtre

```jsx
function FilterList() {
  const [count, setCount] = React.useState(0);
  const [query, setQuery] = React.useState("");

  const users = Array.from({ length: 200 }, (_, i) => `Utilisateur ${i + 1}`);

  const filteredUsers = users.filter((user) =>
    {
        console.log("Filtrage optimisÃ© exÃ©cutÃ© !");
        return user.toLowerCase().includes(query.toLowerCase());
    }
  );

  return (
    <div>
      <h3>Filtrer une grande liste</h3>
      <input
        type="text"
        value={query}
        placeholder="Rechercher un utilisateur"
        onChange={(e) => setQuery(e.target.value)}
      />
      <button onClick={() => setCount((c) => c + 1)}>IncrÃ©menter : {count}</button>
      <ul>
        {filteredUsers.slice(0, 20).map((user) => (
          <li key={user}>{user}</li>
        ))}
      </ul>
    </div>
  );
}

``` 

A chaque clique sur le bouton `IncrÃ©menter`, notre fonction `filteredUsers` est exÃ©cutÃ©e. 

<img src="./img/incrementationSuperflue.PNG" />

En faisant appel Ã  `useMemo`, notre application devient plus performante.

```jsx
const filteredUsers = React.useMemo(() => {
console.log("Filtrage optimisÃ© exÃ©cutÃ© !");
return users.filter((user) =>
    user.toLowerCase().includes(query.toLowerCase())
);
}, [query]);
```

## ğŸ” `useEffect` vs `useMemo`

| ğŸ” CritÃ¨re        | `useMemo`                                        | `useEffect`                                        |
| ---------------- | ------------------------------------------------ | -------------------------------------------------- |
| ğŸ“¦ Sert Ã â€¦        | MÃ©moriser une **valeur**                         | RÃ©agir Ã  un **effet de bord** (API, Ã©vÃ©nement DOM) |
| ğŸ” DÃ©pendances    | Oui (`[deps]`)                                   | Oui (`[deps]`)                                     |
| âš™ï¸ Utilisation    | Renvoyer un rÃ©sultat directement                 | ExÃ©cuter du code (logique, fetch, DOM)             |
| ğŸ”„ AppelÃ© quand ? | Quand une dÃ©pendance change (retourne la valeur) | Quand une dÃ©pendance change (exÃ©cute le code)      |
| â›” Mauvais usage  | Fetch API, console.log, DOM manipulation         | Calcul intensif, filtre de tableau                 |

En rÃ©sumÃ© :

| Tu veuxâ€¦                                                            | Tu utilisesâ€¦  |
| ------------------------------------------------------------------- | ------------- |
| Une **valeur Ã  calculer** (tri, somme, format)                      | âœ… `useMemo`   |
| RÃ©agir Ã  un **changement dâ€™Ã©tat** avec un effet (fetch, DOM, event) | âœ… `useEffect` |


## `React.memo` ou Le mÃ©moÃ¯sage dâ€™un composant

### âœ… Ã€ quoi sert React.memo ?

`React.memo` est une **fonction HOC** (Higher-Order Component) qui permet de **mÃ©moriser un composant fonctionnel**.

### ğŸ” Comportement :
- Compare les `props`
- Si elles n'ont pas changÃ© â†’ ne re-render pas

### ğŸ“¦ Syntaxe

```jsx
const Child = React.memo(function Child(props) {...});
```
ou bien :

```jsx
const Child = (props) => { ... }
export default React.memo(Child);
```

### ğŸ¯ Exemple

Sans `React.memo` :

```jsx
function Parent() {
  const [count, setCount] = useState(0);
  return (
    <>
      <button onClick={() => setCount(count + 1)}>+1</button>
      <Child name="Jean" />
    </>
  );
}

function Child({ name }) {
  console.log("Rendered Child");
  return <p>Nom : {name}</p>;
}

```

âœ… Avec React.memo :

```jsx
const Child = React.memo(function Child({ name }) {
  console.log("Rendered Child");
  return <p>Nom : {name}</p>;
});
```

âœ… Maintenant :

* `Child` **ne se re-render** plus si `name` ne change pas

* MÃªme si `Parent` se re-render (ex: via `count`)

âœ… On va intÃ©grer `React.memo` sur le composant `Display`.

ğŸ¯ Objectif

EmpÃªcher le re-render de `Display` si ses `props` ne changent pas :

  * saisie

  * operator

  * secondValue

  * result

* Petit test : 

```jsx
export default function Display({ saisie, operator, secondValue, result }) {
  console.log("composant Display");
  // Rest du code
}
```

Comme nous pouvons le constater, le composant `Display`  est re-rendu de maniÃ¨re constante Ã  cause du timer.

Solution 1 : l'entourer avec `React.memo`

```jsx
const Display = React.memo(function Display({ saisie, operator, secondValue, result }) {
  return (
    <div className={`${styles.display} ${styles.flexElement}`}>
      <span>{!saisie ? 0 : saisie}</span>
      <span>{operator}</span>
      <span>{!secondValue ? 0 : secondValue}</span>
      <span className={styles.result}>{result ?? 0}</span>
    </div>
  );
});

export default Display;

```

Solution 2 : export directement mÃ©moÃ¯sÃ©

```jsx
function Display({ saisie, operator, secondValue, result }) {
  return (
    <div className={`${styles.display} ${styles.flexElement}`}>
      <span>{!saisie ? 0 : saisie}</span>
      <span>{operator}</span>
      <span>{!secondValue ? 0 : secondValue}</span>
      <span className={styles.result}>{result ?? 0}</span>
    </div>
  );
}

export default React.memo(Display);
```

Le rÃ©sultat parle de lui-mÃªme ! 

* refactorisons le code d'affichage de nos boutons.

```jsx
  <div>
    {/* <div className="buttons"> */}
    <Button onClick={handleNumberClick} label="1" />
    <Button onClick={handleNumberClick} label="2" />
    <Button onClick={handleNumberClick} label="3" />
    <Button onClick={handleOperatorClick} label="+" />

    <Button onClick={handleNumberClick} label="4" />
    <Button onClick={handleNumberClick} label="5" />
    <Button onClick={handleNumberClick} label="6" />
    <Button onClick={handleOperatorClick} label="-" />

    <Button onClick={handleNumberClick} label="7" />
    <Button onClick={handleNumberClick} label="8" />
    <Button onClick={handleNumberClick} label="9" />
    <Button onClick={handleOperatorClick} label="*" />

    <Button onClick={handleNumberClick} label="0" />
    <Button onClick={handleClear} label="C" />
    <Button onClick={handleEqualClick} label="=" />
    <Button onClick={handleOperatorClick} label="/" />
  </div>
```

* crÃ©ons une variable dans laquelle nous allons stocker 
 
```jsx
const paramsButton = [
    {id: 0, action: handleNumberClick, label: '1'},
    {id: 1, action: handleNumberClick, label: '2'},
    {id: 2, action: handleNumberClick, label: '3'},
    {id: 3, action: handleOperatorClick, label: '+'},
    {id: 4, action: handleNumberClick, label: '4'},
    {id: 5, action: handleNumberClick, label: '5'},
    {id: 6, action: handleNumberClick, label: '6'},
    {id: 7, action: handleOperatorClick, label: '-'},
    {id: 8, action: handleNumberClick, label: '7'},
    {id: 9, action: handleNumberClick, label: '8'},
    {id: 10, action: handleNumberClick, label: '9'},
    {id: 11, action: handleOperatorClick, label: '*'},
    {id: 12, action: handleNumberClick, label: '0'},
    {id: 13, action: handleClear, label: 'C'},
    {id: 14, action: handleEqualClick, label: '='},
    {id: 15, action: handleOperatorClick, label: '/'},
] 
```

Avec un `map`, affichons nos boutons de maniÃ¨re plus professionnelle.


Que se passe-t-il lorsque nous modifions le composant `Button` en ajoutant la ligne suivante : 
```jsx
console.log('button render', label);
```
On constate des render intenpestifs de notre composant, ce qui pourrait rÃ©duire les performances de notre application.

Nous allons utiliser `React.memo` comme dans le cas prÃ©cÃ©dent pour resoudre le problÃ¨me !

```jsx
const Button = React.memo(function Button({ onClick, label }) {
    // code
})

export default Button;
```

ğŸ™„ğŸ™„ğŸ™„ je sais pas pour vous mais je ne vois aucun changement ğŸ™„ğŸ™„ğŸ™„

Le vrai problÃ¨me : les fonctions `onClick` **Ã©taient instables**

On passe :

```jsx
<Button onClick={button.action} label={button.label} />
```

Mais `button.action` venait dâ€™un tableau `paramsButton` gÃ©nÃ©rÃ© avec :

```js
const paramsButton = [
  { id: 0, label: "1", action: handleNumberClick },
  ...
];
```

Et `handleNumberClick` Ã©tait une fonction locale du composant Calculator.

â¡ï¸ En React, **chaque fonction dÃ©clarÃ©e dans un composant est recrÃ©Ã©e Ã  chaque render**.
Donc mÃªme si `handleNumberClick` a le mÃªme corps, **sa rÃ©fÃ©rence change tout le temps**.

ğŸ” RÃ©sultat :

   * `paramsButton` est considÃ©rÃ© comme **nouveau**

   * Chaque `button.action` est **une nouvelle fonction**

   * `React.memo(Button)` pense que la prop a changÃ© â†’ re-render forcÃ© âŒ

âœ… **Ã‰tapes pour rÃ©soudre le problÃ¨me**

âœ… 1. **Stabiliser les fonctions** avec `useCallback`

```jsx
const handleNumberClick = React.useCallback((value) => {
    ...
}, [state.operator]);
```

```jsx
const handleClear = React.useCallback(() => {
  dispatch({ type: "CLEAR" });
}, []);
```

```jsx
const handleEqualClick = React.useCallback(() => {
  ...
}, [state.saisie, state.operator, state.secondValue]);
```

```jsx
const handleOperatorClick = React.useCallback((value) => {
  dispatch({ type: "SET_OPERATOR", payload: value });
}, []);
```

âœ… 2. CrÃ©er `paramsButton` avec `useMemo`

```js
   const paramsButton = React.useMemo( () =>[
    {id: 0, action: handleNumberClick, label: '1'},
    {id: 1, action: handleNumberClick, label: '2'},
    {id: 2, action: handleNumberClick, label: '3'},
    {id: 3, action: handleOperatorClick, label: '+'},
    {id: 4, action: handleNumberClick, label: '4'},
    {id: 5, action: handleNumberClick, label: '5'},
    {id: 6, action: handleNumberClick, label: '6'},
    {id: 7, action: handleOperatorClick, label: '-'},
    {id: 8, action: handleNumberClick, label: '7'},
    {id: 9, action: handleNumberClick, label: '8'},
    {id: 10, action: handleNumberClick, label: '9'},
    {id: 11, action: handleOperatorClick, label: '*'},
    {id: 12, action: handleNumberClick, label: '0'},
    {id: 13, action: handleClear, label: 'C'},
    {id: 14, action: handleEqualClick, label: '='},
    {id: 15, action: handleOperatorClick, label: '/'},
  ], [handleNumberClick, handleOperatorClick, handleClear, handleEqualClick]);
```

âœ… Cela Ã©vite de reconstruire paramsButton Ã  chaque render.

## ğŸ§  `useCallback` â€” Le mÃ©moÃ¯sage de fonctions

### ğŸ“Œ DÃ©finition :

```jsx
const memoizedFunction = useCallback(() => {
  // ...code
}, [dÃ©pendances]);
```
> `useCallback` sert Ã  **mÃ©moriser une fonction** pour que sa rÃ©fÃ©rence **reste stable**.

### âœ… Pourquoi câ€™est utile ?
- Les fonctions sont recrÃ©Ã©es Ã  chaque render
- Cela casse `React.memo` sur les composants enfants
- Cela peut redÃ©clencher des `useEffect` inutilement

### ğŸ” UtilisÃ© pour :
- `onClick`, `onChange`, `onSubmit`, etc.
- Fonction passÃ©e Ã  un enfant `memo`

---

## ğŸ§¾ Comparatif final

| CritÃ¨re / Hook           | `useMemo`                                    | `useCallback`                                  | `React.memo` (HOC)                            |
|--------------------------|-----------------------------------------------|------------------------------------------------|------------------------------------------------|
| ğŸ”„ Ce que Ã§a fait         | MÃ©morise une **valeur** calculÃ©e             | MÃ©morise une **fonction**                      | MÃ©morise un **composant** fonctionnel         |
| ğŸ¯ UtilisÃ© pourâ€¦          | Ã‰viter un recalcul coÃ»teux                   | Ã‰viter de recrÃ©er une fonction Ã  chaque render | Ã‰viter un re-render si les `props` n'ont pas changÃ© |
| ğŸ” DÃ©pendances ?          | Oui (`[deps]`)                               | Oui (`[deps]`)                                 | Oui â€” comparaison des `props`                 |
| ğŸ“¤ Retourne quoi ?        | Une **valeur**                               | Une **fonction**                              | Un **composant mÃ©moÃ¯sÃ©**                      |
| ğŸ“¦ Cas typique            | `filter()`, `reduce()`, `sort()`, API heavy  | `onClick`, `onChange`, `onSubmit`              | `Display`, `Button`, composants enfants       |
| ğŸ”¬ Exemple rapide         | `useMemo(() => a + b, [a, b])`               | `useCallback(() => doSomething(), [])`        | `export default React.memo(Component)`       |
| âš ï¸ Attention Ã â€¦           | Ne pas l'utiliser pour des calculs simples   | Fonction doit rester pure                     | Props doivent Ãªtre stables (sinon inutile)   |
| ğŸ“Š Comparaison            | BasÃ©e sur le **rÃ©sultat du calcul**          | BasÃ©e sur la **rÃ©fÃ©rence de la fonction**     | BasÃ©e sur la **rÃ©fÃ©rence des props**         |
| ğŸ§ª Fonctionne avec        | Valeur (objet, tableau, nombre, etc.)        | Fonction (handlers, callbacks)                | Tout composant React (pas hooks)             |
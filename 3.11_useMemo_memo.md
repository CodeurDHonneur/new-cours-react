## `useMemo` ou Le mÃ©moÃ¯sage de valeurs

ðŸ” Ã€ quoi sert `useMemo` ?
`useMemo` sert Ã  mÃ©moriser une valeur qui est coÃ»teuse Ã  **recalculer**, ou **inutile Ã  recalculer** Ã  *chaque re-render*.

âž¡ï¸ Il Ã©vite que cette valeur soit recalculÃ©e si *ses dÃ©pendances* ne changent pas.

ðŸ“¦ Syntaxe

```jsx
const memoizedValue = useMemo(() => computeSomething(), [dependency1, dependency2]);
```

| Situation                                              | Pourquoi `useMemo` ?                            |
| ------------------------------------------------------ | ----------------------------------------------- |
| Calcul intensif (ex: gros filtre, tri, somme)          | Ã‰vite de recalculer inutilement Ã  chaque render |
| DÃ©pendance Ã  une variable stable                       | Ne change que quand la variable change          |
| Passer une valeur stable Ã  un composant enfant (props) | Ã‰vite des re-renders inutiles                   |

ðŸ“Œ Exemple (nous allons crÃ©er un nouveau composant `UseMemo` qui sera rendu par `App`)

ðŸŽ¯ Objectif
  * Tu as une liste dâ€™utilisateurs trÃ¨s longue

  * Tu peux filtrer cette liste en tapant dans un champ

  * Tu peux aussi cliquer sur un compteur qui nâ€™a rien Ã  voir avec le filtre

```jsx
function FilterList() {
  const [count, setCount] = React.useState(0);
  const [query, setQuery] = React.useState("");

  const users = Array.from({ length: 200 }, (_, i) => `Utilisateur ${i + 1}`);

  const filteredUsers = users.filter((user) =>
    {
        console.log("Filtrage optimisÃ© exÃ©cutÃ© !");
        return user.toLowerCase().includes(query.toLowerCase());
    }
  );

  return (
    <div>
      <h3>Filtrer une grande liste</h3>
      <input
        type="text"
        value={query}
        placeholder="Rechercher un utilisateur"
        onChange={(e) => setQuery(e.target.value)}
      />
      <button onClick={() => setCount((c) => c + 1)}>IncrÃ©menter : {count}</button>
      <ul>
        {filteredUsers.slice(0, 20).map((user) => (
          <li key={user}>{user}</li>
        ))}
      </ul>
    </div>
  );
}

``` 

A chaque clique sur le bouton `IncrÃ©menter`, notre fonction `filteredUsers` est exÃ©cutÃ©e. 

<img src="./img/incrementationSuperflue.PNG" />

En faisant appel Ã  `useMemo`, notre application devient plus performante.

```jsx
const filteredUsers = React.useMemo(() => {
console.log("Filtrage optimisÃ© exÃ©cutÃ© !");
return users.filter((user) =>
    user.toLowerCase().includes(query.toLowerCase())
);
}, [query]);
```

Comparatif rapide useMemo vs `useEffect`

| ðŸ” CritÃ¨re | `useMemo` | `useEffect` |
|------------|-----------|-------------|
| ðŸ“¦ Sert Ã â€¦ | MÃ©moriser une **valeur** | RÃ©agir Ã  un **effet de bord** (API, Ã©vÃ©nement DOM) |
| ðŸ” DÃ©pendances | Oui (`[deps]`) | Oui (`[deps]`) |
| âš™ï¸ Utilisation | Renvoyer un rÃ©sultat directement | ExÃ©cuter du code (logique, fetch, DOM) |
| ðŸ”„ AppelÃ© quand ? | Quand une dÃ©pendance change (retourne la valeur) | Quand une dÃ©pendance change (exÃ©cute le code) |
| â›” Mauvais usage | Fetch API, console.log, DOM manipulation | Calcul intensif, filtre de tableau |

En rÃ©sumÃ© :

| Tu veuxâ€¦ | Tu utilisesâ€¦ |
|----------|--------------|
| Une **valeur Ã  calculer** (tri, somme, format) | âœ… `useMemo` |
| RÃ©agir Ã  un **changement dâ€™Ã©tat** avec un effet (fetch, DOM, event) | âœ… `useEffect` |


## `React.memo` ou Le mÃ©moÃ¯sage dâ€™un composant

âœ… Ã€ quoi sert React.memo ?

`React.memo` est une **fonction HOC** (Higher-Order Component) qui permet de **mÃ©moriser un composant fonctionnel**.

ðŸ” Ce quâ€™il fait

  * Il **compare les props** du composant enfant

  * Si les props **nâ€™ont pas changÃ©**, il **empÃªche le re-render**

  * âš ï¸ La comparaison est **shallow** (superficielle)

Syntaxe
```jsx
const Child = React.memo(function Child(props) {
  // ...
});
```

ou bien :

```jsx
const Child = (props) => { ... }
export default React.memo(Child);
```

ðŸŽ¯ Exemple clair

Sans `React.memo` :

```jsx
function Parent() {
  const [count, setCount] = useState(0);
  return (
    <>
      <button onClick={() => setCount(count + 1)}>+1</button>
      <Child name="Jean" />
    </>
  );
}

function Child({ name }) {
  console.log("Rendered Child");
  return <p>Nom : {name}</p>;
}

```

âœ… Avec React.memo :

```jsx
const Child = React.memo(function Child({ name }) {
  console.log("Rendered Child");
  return <p>Nom : {name}</p>;
});
```
âœ… Maintenant :

* `Child` **ne se re-render** plus si `name` ne change pas

* MÃªme si `Parent` se re-render (ex: via `count`)

âœ… On va intÃ©grer `React.memo` sur le composant `Display`.

ðŸŽ¯ Objectif

EmpÃªcher le re-render de `Display` si ses `props` ne changent pas :

  * saisie

  * operator

  * secondValue

  * result

* Petit test : 

```jsx
export default function Display({ saisie, operator, secondValue, result }) {
  console.log("composant Display");
  // Rest du code
}
```

Comme nous pouvons le constater, le composant `Display`  est re-rendu de maniÃ¨re constante Ã  cause du timer.

Solution 1 : l'entourer avec `React.memo`

```jsx
const Display = React.memo(function Display({ saisie, operator, secondValue, result }) {
  return (
    <div className={`${styles.display} ${styles.flexElement}`}>
      <span>{!saisie ? 0 : saisie}</span>
      <span>{operator}</span>
      <span>{!secondValue ? 0 : secondValue}</span>
      <span className={styles.result}>{result ?? 0}</span>
    </div>
  );
});

export default Display;

```

Solution 2 : export directement mÃ©moÃ¯sÃ©

```jsx
function Display({ saisie, operator, secondValue, result }) {
  return (
    <div className={`${styles.display} ${styles.flexElement}`}>
      <span>{!saisie ? 0 : saisie}</span>
      <span>{operator}</span>
      <span>{!secondValue ? 0 : secondValue}</span>
      <span className={styles.result}>{result ?? 0}</span>
    </div>
  );
}

export default React.memo(Display);
```

Le rÃ©sultat parle de lui-mÃªme ! 


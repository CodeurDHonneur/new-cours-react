# ğŸ“š `useMemo`, `useCallback` et `React.memo` en React

---

## `useMemo` ou Le mÃ©moÃ¯sage de valeurs

### ğŸ” Ã€ quoi sert `useMemo` ?
`useMemo` sert Ã  mÃ©moriser une valeur qui est coÃ»teuse Ã  **recalculer**, ou **inutile Ã  recalculer** Ã  *chaque re-render*.

â¡ï¸ Il Ã©vite que cette valeur soit recalculÃ©e si *ses dÃ©pendances* ne changent pas.

### ğŸ“¦ Syntaxe

```jsx
const memoizedValue = useMemo(() => computeSomething(), [dependency1, dependency2]);
```

### âœ… Situations typiques

| Situation                                              | Pourquoi `useMemo` ?                            |
| ------------------------------------------------------ | ----------------------------------------------- |
| Calcul intensif (ex: gros filtre, tri, somme)          | Ã‰vite de recalculer inutilement Ã  chaque render |
| DÃ©pendance Ã  une variable stable                       | Ne change que quand la variable change          |
| Passer une valeur stable Ã  un composant enfant (props) | Ã‰vite des re-renders inutiles                   |

### ğŸ¯ Exemple : Filtrage dâ€™une longue liste

Nous allons crÃ©er un nouveau composant `FilterList` qui sera rendu par `App`.

**ğŸ¯ Objectif**:
- Tu as une liste dâ€™utilisateurs trÃ¨s longue.
- Tu peux filtrer cette liste en tapant dans un champ.
- Tu peux aussi cliquer sur un compteur qui nâ€™a rien Ã  voir avec le filtre.

```jsx
function FilterList() {
  const [count, setCount] = React.useState(0);
  const [query, setQuery] = React.useState("");

  const users = Array.from({ length: 200 }, (_, i) => `Utilisateur ${i + 1}`);

  const filteredUsers = users.filter((user) => {
    console.log("Filtrage optimisÃ© exÃ©cutÃ© !");
    return user.toLowerCase().includes(query.toLowerCase());
  });

  return (
    <div>
      <h3>Filtrer une grande liste</h3>
      <input
        type="text"
        value={query}
        placeholder="Rechercher un utilisateur"
        onChange={(e) => setQuery(e.target.value)}
      />
      <button onClick={() => setCount((c) => c + 1)}>IncrÃ©menter : {count}</button>
      <ul>
        {filteredUsers.slice(0, 20).map((user) => (
          <li key={user}>{user}</li>
        ))}
      </ul>
    </div>
  );
}
```

Ã€ chaque clic sur le bouton `IncrÃ©menter`, notre fonction `filteredUsers` est exÃ©cutÃ©e.

<img src="./img/incrementationSuperflue.PNG" />

En faisant appel Ã  `useMemo`, notre application devient plus performante.

```jsx
const filteredUsers = React.useMemo(() => {
  console.log("Filtrage optimisÃ© exÃ©cutÃ© !");
  return users.filter((user) =>
    user.toLowerCase().includes(query.toLowerCase())
  );
}, [query]);
```

---

## ğŸ” `useEffect` vs `useMemo`

| ğŸ” CritÃ¨re        | `useMemo`                                        | `useEffect`                                        |
| ---------------- | ------------------------------------------------ | -------------------------------------------------- |
| ğŸ“¦ Sert Ã â€¦        | MÃ©moriser une **valeur**                         | RÃ©agir Ã  un **effet de bord** (API, Ã©vÃ©nement DOM) |
| ğŸ” DÃ©pendances    | Oui (`[deps]`)                                   | Oui (`[deps]`)                                     |
| âš™ï¸ Utilisation    | Renvoyer un rÃ©sultat directement                 | ExÃ©cuter du code (logique, fetch, DOM)             |
| ğŸ”„ AppelÃ© quand ? | Quand une dÃ©pendance change (retourne la valeur) | Quand une dÃ©pendance change (exÃ©cute le code)      |
| â›” Mauvais usage  | Fetch API, console.log, DOM manipulation         | Calcul intensif, filtre de tableau                 |

### En rÃ©sumÃ© :

| Tu veuxâ€¦                                                            | Tu utilisesâ€¦  |
| ------------------------------------------------------------------- | ------------- |
| Une **valeur Ã  calculer** (tri, somme, format)                      | âœ… `useMemo`   |
| RÃ©agir Ã  un **changement dâ€™Ã©tat** avec un effet (fetch, DOM, event) | âœ… `useEffect` |

---

## `React.memo` ou Le mÃ©moÃ¯sage dâ€™un composant

### âœ… Ã€ quoi sert `React.memo` ?

`React.memo` est une **fonction HOC** (Higher-Order Component) qui permet de **mÃ©moriser un composant fonctionnel**.

### ğŸ” Comportement :
- Compare les `props`
- Si elles n'ont pas changÃ© â†’ ne re-render pas

### ğŸ“¦ Syntaxe

```jsx
const Child = React.memo(function Child(props) {...});
```
ou bien :

```jsx
const Child = (props) => { ... }
export default React.memo(Child);
```

### ğŸ¯ Exemple

Sans `React.memo` :

```jsx
function Parent() {
  const [count, setCount] = useState(0);
  return (
    <>
      <button onClick={() => setCount(count + 1)}>+1</button>
      <Child name="Jean" />
    </>
  );
}

function Child({ name }) {
  console.log("Rendered Child");
  return <p>Nom : {name}</p>;
}
```

âœ… Avec `React.memo` :

```jsx
const Child = React.memo(function Child({ name }) {
  console.log("Rendered Child");
  return <p>Nom : {name}</p>;
});
```

âœ… Maintenant :

* `Child` **ne se re-render** plus si `name` ne change pas.
* MÃªme si `Parent` se re-render (ex: via `count`).

âœ… On va intÃ©grer `React.memo` sur le composant `Display`.

**ğŸ¯ Objectif**: EmpÃªcher le re-render de `Display` si ses `props` ne changent pas.

* **saisie**
* **operator**
* **secondValue**
* **result**

* Petit test : 

```jsx
export default function Display({ saisie, operator, secondValue, result }) {
  console.log("composant Display");
  // Rest du code
}
```

Comme nous pouvons le constater, le composant `Display` est re-rendu de maniÃ¨re constante Ã  cause du timer.

### Solution 1 : l'entourer avec `React.memo`

```jsx
const Display = React.memo(function Display({ saisie, operator, secondValue, result }) {
  return (
    <div className={`${styles.display} ${styles.flexElement}`}>
      <span>{!saisie ? 0 : saisie}</span>
      <span>{operator}</span>
      <span>{!secondValue ? 0 : secondValue}</span>
      <span className={styles.result}>{result ?? 0}</span>
    </div>
  );
});

export default Display;
```

### Solution 2 : export directement mÃ©moÃ¯sÃ©

```jsx
function Display({ saisie, operator, secondValue, result }) {
  return (
    <div className={`${styles.display} ${styles.flexElement}`}>
      <span>{!saisie ? 0 : saisie}</span>
      <span>{operator}</span>
      <span>{!secondValue ? 0 : secondValue}</span>
      <span className={styles.result}>{result ?? 0}</span>
    </div>
  );
}

export default React.memo(Display);
```

Le rÃ©sultat parle de lui-mÃªme ! 

---

### Refactorisation des boutons

* CrÃ©e une variable pour stocker les paramÃ¨tres des boutons :

```jsx
const paramsButton = [
  { id: 0, action: handleNumberClick, label: '1' },
  { id: 1, action: handleNumberClick, label: '2' },
  { id: 2, action: handleNumberClick, label: '3' },
  { id: 3, action: handleOperatorClick, label: '+' },
  { id: 4, action: handleNumberClick, label: '4' },
  { id: 5, action: handleNumberClick, label: '5' },
  { id: 6, action: handleNumberClick, label: '6' },
  { id: 7, action: handleOperatorClick, label: '-' },
  { id: 8, action: handleNumberClick, label: '7' },
  { id: 9, action: handleNumberClick, label: '8' },
  { id: 10, action: handleNumberClick, label: '9' },
  { id: 11, action: handleOperatorClick, label: '*' },
  { id: 12, action: handleNumberClick, label: '0' },
  { id: 13, action: handleClear, label: 'C' },
  { id: 14, action: handleEqualClick, label: '=' },
  { id: 15, action: handleOperatorClick, label: '/' },
];
```

Avec un `map`, affichons nos boutons de maniÃ¨re plus professionnelle.

### ProblÃ¨me des renders intempestifs

Lorsque nous modifions le composant `Button` en ajoutant la ligne suivante : 

```jsx
console.log('button render', label);
```

Nous constatons des renders intempestifs de notre composant, ce qui pourrait rÃ©duire les performances de notre application.

### Stabiliser les fonctions

Nous allons utiliser `React.memo` pour rÃ©soudre le problÃ¨me :

```jsx
const Button = React.memo(function Button({ onClick, label }) {
  // code
});

export default Button;
```

ğŸ” **ProblÃ¨me des fonctions instables** :

Les fonctions `onClick` de `paramsButton` Ã©taient instables, car elles Ã©taient recrÃ©Ã©es Ã  chaque render.

### RÃ©solution

1. **Stabiliser les fonctions** avec `useCallback` :

```jsx
const handleNumberClick = React.useCallback((value) => {
  // logique
}, [state.operator]);

const handleClear = React.useCallback(() => {
  dispatch({ type: "CLEAR" });
}, []);

const handleEqualClick = React.useCallback(() => {
  // logique
}, [state.saisie, state.operator, state.secondValue]);

const handleOperatorClick = React.useCallback((value) => {
  dispatch({ type: "SET_OPERATOR", payload: value });
}, []);
```

2. **CrÃ©er `paramsButton` avec `useMemo`** :

```js
const paramsButton = React.useMemo(() => [
  { id: 0, action: handleNumberClick, label: '1' },
  { id: 1, action: handleNumberClick, label: '2' },
  // ...
], [handleNumberClick, handleOperatorClick, handleClear, handleEqualClick]);
```

âœ… Cela Ã©vite de reconstruire `paramsButton` Ã  chaque render.

---

## ğŸ§  `useCallback` â€” Le mÃ©moÃ¯sage de fonctions

### ğŸ“Œ DÃ©finition :

```jsx
const memoizedFunction = useCallback(() => {
  // ...code
}, [dÃ©pendances]);
```

> `useCallback` sert Ã  **mÃ©moriser une fonction** pour que sa rÃ©fÃ©rence **reste stable**.

### âœ… Pourquoi câ€™est utile ?
- Les fonctions sont recrÃ©Ã©es Ã  chaque render.
- Cela casse `React.memo` sur les composants enfants.
- Cela peut redÃ©clencher des `useEffect` inutilement.

### ğŸ” UtilisÃ© pour :
- `onClick`, `onChange`, `onSubmit`, etc.
- Fonction passÃ©e Ã  un enfant `memo`.

---

## ğŸ§¾ Comparatif final

| CritÃ¨re / Hook           | `useMemo`                                    | `useCallback`                                  | `React.memo` (HOC)                            |
|--------------------------|-----------------------------------------------|------------------------------------------------|------------------------------------------------|
| ğŸ”„ Ce que Ã§a fait         | MÃ©morise une **valeur**                      | MÃ©morise une **fonction**                      | MÃ©morise un **composant** fonctionnel         |
| ğŸ¯ UtilisÃ© pourâ€¦          | Ã‰viter un recalcul coÃ»teux                   | Ã‰viter de recrÃ©er une fonction Ã  chaque render | Ã‰viter un re-render si les `props` n'ont pas changÃ© |
| ğŸ” DÃ©pendances ?          | Oui (`[deps]`)                               | Oui (`[deps]`)                                 | Oui â€” comparaison des `props`                 |
| ğŸ“¤ Retourne quoi ?        | Une **valeur**                               | Une **fonction**                              | Un **composant mÃ©moÃ¯sÃ©**                      |
| ğŸ“¦ Cas typique            | `filter()`, `reduce()`, `sort()`, API heavy  | `onClick`, `onChange`, `onSubmit`              | `Display`, `Button`, composants enfants       |
| ğŸ”¬ Exemple rapide         | `useMemo(() => a + b, [a, b])`               | `useCallback(() => doSomething(), [])`        | `export default React.memo(Component)`       |
| âš ï¸ Attention Ã â€¦           | Ne pas l'utiliser pour des calculs simples   | Fonction doit rester pure                     | Props doivent Ãªtre stables (sinon inutile)   |
| ğŸ“Š Comparaison            | BasÃ©e sur le **rÃ©sultat du calcul**          | BasÃ©e sur la **rÃ©fÃ©rence de la fonction**     | BasÃ©e sur la **rÃ©fÃ©rence des props**         |
| ğŸ§ª Fonctionne avec        | Valeur (objet, tableau, nombre, etc.)        | Fonction (handlers, callbacks)                | Tout composant React (pas hooks)             |
## Tableaux

### DÃ©finition : 
**Un tableau** en JavaScript est un objet utilisÃ© pour stocker plusieurs valeurs dans une seule variable.

### DÃ©claration : 
Les tableaux peuvent Ãªtre crÃ©Ã©s en utilisant des crochets `[]` ou le constructeur `Array`.

```js
// Utilisation des crochets
let fruits = ["pomme", "banane", "cerise"];

// Utilisation du constructeur Array
let nombres = new Array(1, 2, 3, 4, 5);
```

### AccÃ©der aux donnÃ©es d'un tableau simple
Les tableaux sont indexÃ©s Ã  partir de `zÃ©ro`: le premier Ã©lÃ©ment d'un tableau a pour indice `0`, et la position du dernier Ã©lÃ©ment est donnÃ©e par la propriÃ©tÃ© `.length` (propriÃ©tÃ© permettant d'avoir la taille d'un tableau) moins `1`.

**NB**: Si on utilise un indice en dehors de cet intervalle, le rÃ©sultat sera `'undefined'`.

```js
let fruits = ["pomme", "banane", "cerise"];
console.log(fruits[0]); // "pomme"
console.log(fruits[1]); // "banane"
console.log(fruits[2]) || console.log(fruits[fruits.length - 1]); // "cerise"
```

### Modifier les donnÃ©es d'un tableau simple

```js
let fruits = ["pomme", "banane", "cerise"]; 
fruits[0] = "avocat"; // Notre tableau vaudra maintenant ["avocat", "banane", "cerise"]
fruits[5] = "papaye"; // Notre tableau vaudra dÃ©sormais ["avocat", "banane", "cerise", undefined, undefined, "papaye"]
```

**NB**: le tableau `fruits` est modifiÃ© pour inclure des valeurs `'undefined'` aux indices `3` et `4`, car ils n'ont pas Ã©tÃ© explicitement dÃ©finis. Il est important de noter que la crÃ©ation de `"trous"` dans un tableau (indices non dÃ©finis) peut parfois conduire Ã  des comportements inattendus ou Ã  des difficultÃ©s lors de la manipulation du tableau.

### Tableaux imbriquÃ©s
Les tableaux peuvent contenir tout type de variables, y compris des tableaux. Quand un tableau ne contient que des variables qui sont Ã  leur tour des tableaux, on parlera de tableaux `imbriquÃ©s` ou `multidimensionnels`.

**Exemple :**
```js
let matrice = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
```

### AccÃ©der aux donnÃ©es d'un tableau imbriquÃ©
ConsidÃ©rant un tableau 2D, pour trouver un Ã©lÃ©ment spÃ©cifique, vous devez d'abord choisir le bon sous-tableau, puis l'Ã©lÃ©ment Ã  l'intÃ©rieur de ce sous-tableau.

```js
let matrice = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

// AccÃ©der aux Ã©lÃ©ments
console.log(matrice[0][0]); // Affiche 1
console.log(matrice[1][2]); // Affiche 6
console.log(matrice[2][1]); // Affiche 8
```

### Modifier un Ã©lÃ©ment

Avant :
```js
console.log(matrice[0][1]); // Affiche 2
```

Modifier :
```js
matrice[0][1] = 10;
```

AprÃ¨s :
```js
console.log(matrice[0][1]); // Affiche 10
```

### 10 MÃ©thodes importantes sur les tableaux

#### 1. map()
Sert Ã  transformer chaque Ã©lÃ©ment dâ€™une liste. 

**Exemple :**
```js
const array1 = [1, 4, 9, 16];
const map1 = array1.map((x) => x * 2);
console.log(map1); // RÃ©ponse:  [2, 8, 18, 32]
```

#### 2. filter()
Sert Ã  examiner chaque Ã©lÃ©ment dâ€™une liste et Ã  ne garder que ceux qui respectent une condition prÃ©cise.

**Exemple :**
Tu as un panier de fruits : ğŸğŸŒğŸğŸ‡ğŸŒ. 
Tu veux ne garder que les pommes ğŸ. 

`filter()` va vÃ©rifier chaque fruit et garder seulement les pommes. 
RÃ©sultat : ğŸğŸ.

En rÃ©sumÃ© : `filter()` te permet de sÃ©lectionner dans une liste uniquement les Ã©lÃ©ments qui respectent une rÃ¨gle que tu dÃ©finis. Tout le reste est ignorÃ©.

#### 3. reduce() 
Sert Ã  combiner tous les Ã©lÃ©ments pour en faire un seul (exemple : une somme). 

**Exemple :**
```js
const coins = [10, 20, 30];
const total = coins.reduce((sum, coin) => sum + coin, 0);
console.log(total); // 60
```
**Explication du code :**
* `coins` est ta liste : [10, 20, 30].
* `reduce()` fonctionne comme ceci :
  * DÃ©but : La somme (sum) commence Ã  0. 
  * Ã‰tape 1 : Ajoute 10 â†’ 0 + 10 = 10.
  * Ã‰tape 2 : Ajoute 20 â†’ 10 + 20 = 30.
  * Ã‰tape 3 : Ajoute 30 â†’ 30 + 30 = 60.
  * RÃ©sultat final : 60.

#### 4. find() 
Parcourt la liste et sâ€™arrÃªte dÃ¨s quâ€™il trouve le premier Ã©lÃ©ment qui correspond Ã  ce que tu cherches. Tout ce qui vient aprÃ¨s est ignorÃ©.

**Exemple :**
```js
const ages = [15, 18, 21, 14];
const adultAge = ages.find(age => age >= 18);
console.log(adultAge); // Affiche : 18
```

**Explication du code :** 
* `ages` : Ta liste des Ã¢ges. 
* `find()` : Cherche le premier Ã¢ge qui est supÃ©rieur ou Ã©gal Ã  18.
* RÃ©sultat : 18, car câ€™est le premier Ã¢ge qui respecte la condition. ğŸ˜Š

#### 5. push()
Sert Ã  ajouter un Ã©lÃ©ment Ã  la fin dâ€™une liste. 

**Exemple :**
```js
let fruits = ["pomme", "banane", "cerise"]; 
let countArray = fruits.push("avocat"); 
console.log(fruits); // ["pomme", "banane", "cerise", "avocat"]
```
`countArray` vaudra 4 (la nouvelle longueur du tableau).

#### 6. pop() 
Sert Ã  retirer le dernier Ã©lÃ©ment dâ€™une liste. 

**Exemple :**
```js
let fruits = ["pomme", "banane", "orange"]; 
const removedFruit = fruits.pop();
console.log(fruits); // Affiche ["pomme", "banane"]
console.log(removedFruit); // Affiche : "orange"
```

#### 7. shift() 
La mÃ©thode `shift()` permet de retirer le premier Ã©lÃ©ment d'un tableau et de renvoyer cet Ã©lÃ©ment. Elle modifie donc la longueur du tableau.

**Exemple :**
```js
let fruits = ["pomme", "banane", "cerise"]; 
const firstElement = fruits.shift();
console.log(fruits); // Affiche ["banane", "cerise"]
console.log(firstElement); // Affiche "pomme"
```

#### 8. unshift() 
Cette mÃ©thode ajoute un ou plusieurs Ã©lÃ©ments au dÃ©but d'un tableau et renvoie la nouvelle longueur du tableau.

**Exemple :**
```js
let fruits = ["pomme", "banane", "cerise"]; 
const count = fruits.unshift("papaye", "ananas");
console.log(fruits); // Affiche ["papaye", "ananas", "pomme", "banane", "cerise"]
console.log(count); // Affiche 5
```

#### 9. slice() 
Sert Ã  copier une partie dâ€™une liste. 

**Exemple :**
```js
const fruits = ["pomme", "banane", "orange", "kiwi"];
const selectedFruits = fruits.slice(1, 3);
console.log(selectedFruits); // Affiche ["banane", "orange"]
```

**Explication du code :**
* Tu veux copier seulement banane et orange. 
* RÃ©sultat final : ["banane", "orange"].

#### 10. splice()
Sert Ã  ajouter, enlever ou remplacer des Ã©lÃ©ments dans une liste. 

**Exemple :**

* Pour ajouter : 
```js
const fruits = ["pomme", "kiwi"];
fruits.splice(1, 0, "banane"); // Ã€ l'index 1, ajoute "banane"
console.log(fruits); // Affiche : ["pomme", "banane", "kiwi"]
```

* Pour enlever : 
```js
const fruits = ["pomme", "banane", "kiwi"];
fruits.splice(1, 1);
console.log(fruits); // Affiche : ["pomme", "kiwi"]
```
### RÃ©sumÃ© de mÃ©thodes 

ğŸ› ï¸ MÃ©thode | ğŸ¯ CatÃ©gorie | ğŸ” Exemple (Emojis) | ğŸ“ Description
|-----------|--------------|----------------------|---------------|
push("ğŸ˜¡") | Modification | ğŸ˜„ ğŸ¤” ğŸ˜¢ â†’ ğŸ˜„ ğŸ¤” ğŸ˜¢ ğŸ˜¡ | Ajoute Ã  la fin
pop() | Modification | ğŸ˜„ ğŸ¤” ğŸ˜¢ ğŸ˜¡ â†’ ğŸ˜„ ğŸ¤” ğŸ˜¢ | Supprime le dernier Ã©lÃ©ment
unshift("ğŸ˜¡") | Modification | ğŸ˜„ ğŸ¤” ğŸ˜¢ â†’ ğŸ˜¡ ğŸ˜„ ğŸ¤” ğŸ˜¢ | Ajoute au dÃ©but
shift() | Modification | ğŸ˜„ ğŸ¤” ğŸ˜¢ â†’ ğŸ¤” ğŸ˜¢ | Supprime le premier Ã©lÃ©ment
splice(1, 2) | Modification | ğŸ˜„ ğŸ¤” ğŸ˜¢ ğŸ˜¡ â†’ ğŸ˜„ ğŸ˜¡ | Retire ou remplace une portion
reverse() | Modification | ğŸ˜„ ğŸ¤” ğŸ˜¢ â†’ ğŸ˜¢ ğŸ¤” ğŸ˜„ | Inverse lâ€™ordre
sort() | Modification | ["b", "a", "c"] â†’ ["a", "b", "c"] | Trie comme des chaÃ®nes
includes("ğŸ˜¢") | Recherche | ğŸ˜„ ğŸ¤” ğŸ˜¢ â†’ true | VÃ©rifie si un Ã©lÃ©ment existe
indexOf("ğŸ˜¢") | Recherche | ğŸ˜„ ğŸ¤” ğŸ˜¢ â†’ 2 | Premier index de lâ€™Ã©lÃ©ment
lastIndexOf("ğŸ˜¢") | Recherche | ğŸ˜¢ ğŸ¤” ğŸ˜¢ â†’ 2 | Dernier index de lâ€™Ã©lÃ©ment
find(fn) | Recherche | [1, 2, 3].find(x => x > 1) â†’ 2 | Premier Ã©lÃ©ment qui satisfait une condition
findIndex(fn) | Recherche | [1, 2, 3].findIndex(x => x > 1)â†’1 | Index du premier Ã©lÃ©ment qui satisfait une condition
some(fn) | Test | â†’ true / false | VÃ©rifie si au moins un Ã©lÃ©ment satisfait la condition
every(fn) | Test | â†’ true / false | VÃ©rifie si tous les Ã©lÃ©ments satisfont la condition
map(fn) | Transformation | ğŸ˜„ ğŸ¤” â†’ ğŸ˜ ğŸ˜ | Transforme chaque Ã©lÃ©ment
filter(fn) | Transformation | ğŸ˜„ ğŸ¤” ğŸ˜¢ â†’ ğŸ¤” ğŸ˜¢ | Filtre certains Ã©lÃ©ments
reduce(fn) | Transformation | [1, 2, 3] â†’ 6 | RÃ©duit Ã  une seule valeur
flat() | Transformation | [1, [2, 3]] â†’ [1, 2, 3] | Aplati les tableaux imbriquÃ©s
flatMap(fn) | Transformation | Combinaison de map + flat | 
slice(1, 3) | Extraction | ğŸ˜„ ğŸ¤” ğŸ˜¢ ğŸ˜¡ â†’ ğŸ¤” ğŸ˜¢ | Copie une portion sans modifier lâ€™original
concat(arr2) | Fusion | [1, 2].concat([3, 4]) â†’ [1, 2, 3, 4] | Combine plusieurs tableaux
join("-") | ChaÃ®ne de caractÃ¨res | ğŸ˜„ ğŸ¤” ğŸ˜¢ â†’ "ğŸ˜„-ğŸ¤”-ğŸ˜¢" | CrÃ©e une string Ã  partir du tableau
toString() | ChaÃ®ne de caractÃ¨res | [1, 2, 3] â†’ "1,2,3" | Convertit le tableau en chaÃ®ne
fill("ğŸ˜") | Remplissage | new Array(3).fill("ğŸ˜") â†’ ğŸ˜ ğŸ˜ ğŸ˜ | Remplit tout le tableau avec une valeur
copyWithin(1, 0) | Copie interne | [1, 2, 3] â†’ [1, 1, 2] | Copie une partie Ã  un autre emplacement

### Exercices 

##### Exercice 1 : TÃ©lÃ©portation et Fusion

**DifficultÃ©: Medium**

Il vous est donnÃ© deux tableaux et un index. CrÃ©ez une fonction `frankenSplice(arr1, arr2, index)`. Copiez dans l'ordre chaque Ã©lÃ©ment du premier tableau dans le second tableau. Commencez par insÃ©rer les Ã©lÃ©ments Ã  l'index `n` du second tableau. Retournez le tableau final. **NB**: Les tableaux de dÃ©part restent inchangÃ©s aprÃ¨s l'exÃ©cution des fonctions.

**Tests:**
- `frankenSplice([1, 2, 3], [4, 5], 1)` devrait retourner `[4, 1, 2, 3, 5]`
- `frankenSplice([1, 2], ["a", "b"], 1)` devrait retourner `["a", 1, 2, "b"]`
- `frankenSplice(["claw", "tentacle"], ["head", "shoulders", "knees", "toes"], 2)` devrait retourner `["head", "shoulders", "claw", "tentacle", "knees", "toes"]`
- `frankenSplice([1, 2, 3, 4], [], 0)` devrait retourner `[1, 2, 3, 4]`

##### Exercice 2 : OÃ¹ devrais-je Ãªtre

**DifficultÃ©: Moyenne**

CrÃ©ez une fonction `getIndexToIns(arr, toInsert)`. Renvoyez l'indice le plus bas auquel une valeur (deuxiÃ¨me argument) doit Ãªtre insÃ©rÃ©e dans un tableau (premier argument) une fois qu'il a Ã©tÃ© triÃ©. La valeur renvoyÃ©e doit Ãªtre un nombre.

**Tests:**
- `getIndexToIns([10, 20, 30, 40, 50], 35)` devrait renvoyer 3.
- `getIndexToIns([10, 20, 30, 40, 50], 30)` devrait renvoyer 2.
- `getIndexToIns([40, 60], 50)` devrait renvoyer 1.
- `getIndexToIns([3, 10, 5], 3)` devrait renvoyer 0.
- `getIndexToIns([5, 3, 20, 3], 5)` devrait renvoyer 2.
- `getIndexToIns([2, 20, 10], 19)` devrait renvoyer 2.
- `getIndexToIns([2, 5, 10], 15)` devrait renvoyer 3.
- `getIndexToIns([], 1)` devrait renvoyer 0.
En React, **les événements** sont des actions déclenchées par l’utilisateur ou le navigateur (comme un clic, une saisie clavier, un survol de souris, etc.). React gère les événements d'une manière similaire au DOM classique, mais avec quelques différences : par exemple, les noms des événements sont en **camelCase** (`onClick` au lieu de `onclick`), et au lieu de passer une chaîne de caractères, on passe une **fonction** comme gestionnaire.

Nous allons customiser notre calculatrice dans le but de découvrir les événements.

## Étape 1 : Comprendre et améliorer `onClick`

### Ce qu'on fait
* Tu utilises déjà `onClick` sur chaque bouton dans ta calculatrice.

* Chaque bouton appelle une fonction différente (`handleNumberClick`, `handleOperatorClick`, etc.)

* Nous allons :

  * **Ajouter des** `console.log` dans chaque fonction

  * **Voir ce qui se passe dans la console** à chaque clic

  * **Mieux comprendre comment l'événement fonctionne**

### Instructions Pratiques
Dans ton fichier `Calculator.jsx`, fais ceci :

##### 1. Modifie `handleNumberClick`

```js
const handleNumberClick = (value) => {
    console.log(`Chiffre cliqué : ${value}`);
    //...
};
```

##### 2. Modifie `handleOperatorClick`

```js
const handleOperatorClick = (value) => {
    console.log(`Opérateur cliqué : ${value}`);
    //...
};
```
##### 3. Modifie `handleClear`

```js
const handleClear = () => {
    console.log("Calcul effacé !");
    //...
};
```

##### 4. Modifie `handleEqualClick`

```js
const handleEqualClick = () => {
    console.log("Calcul effectué !");
   //...
};
```

## Étape 2 — `onMouseEnter` et `onMouseLeave`

### Ce qu'on fait
* On veut ajouter un effet visuel quand on passe la souris sur un bouton.

* Pour ça, on utilise deux événements React :

   * `onMouseEnter` ➔ la souris entre dans le bouton.

   * `onMouseLeave` ➔ la souris sort du bouton.

L'objectif est d'**apprendre à utiliser ces deux événements** et de rendre la calculatrice **plus interactive** !

### Instructions Pratiques
On va modifier  `Button.jsx`.

On ajoute :

* Un **état** pour savoir si la souris est sur le bouton (`hover`)

* Des **événements** `onMouseEnter` et `onMouseLeave`

* Un **style dynamique** qui change en fonction de hover

```js
import React from 'react';

export default function Button({ onClick, label }) {
    const [hover, setHover] = React.useState(false);

    return (
        <button
            onClick={() => onClick(label)}
            onMouseEnter={() => setHover(true)}
            onMouseLeave={() => setHover(false)}
            style={{
                backgroundColor: hover ? '#e0e0e0' : 'white',
                border: '1px solid #ccc',
                padding: '10px',
                margin: '5px',
                width: '40px',
                cursor: 'pointer',
                transition: 'background-color 0.3s',
            }}
        >
            {label}
        </button>
    );
}

```

## Étape 3 — Ajouter le support clavier (`onKeyDown`)

### Ce qu'on fait
* **Jusqu’ici** tu cliquais avec la souris sur les boutons.

* **Maintenant** on va pouvoir **utiliser le clavier** pour entrer les chiffres et les opérateurs.

Pour ça, on va utiliser l'événement `onKeyDown` ➔ détecter quand une touche du clavier est pressée.

### Instructions Pratiques
On va ajouter un gestionnaire d’événements sur la `div` principale du composant `Calculator`.

#### 1. Ajouter `onKeyDown` dans Calculator
Dans le fichier `Calculator.jsx`, commençons par :

1. Ajouter une fonction qui va écouter les touches du clavier

2. L'attacher à ton composant `div` principale

3. Penser à ajouter `tabIndex` sur la `div` pour qu’elle soit **focusable** (sinon React n'écoutera pas les événements clavier).

```js
const handleKeyDown = (event) => {
    const key  = event.key;
    console.log(`Touche pressée : ${key}`);

    if (['/', '*', '-', '+', 'Enter', '=', 'c', 'C'].includes(key) || !isNaN(Number(key))) {
        event.preventDefault(); // empêcher les comportements par défauts du navigateur
    }

    if (!isNaN(key)) {
        // Si c'est un chiffre
        handleNumberClick(key);
    } else if (['+', '-', '*', '/'].includes(key)) {
        // Si c'est un opérateur
        handleOperatorClick(key);
    } else if (key === 'Enter') {
        // Si c'est Entrée
        handleEqualClick();
    } else if (key === 'c' || key === 'C') {
        // Si c'est C ou c
        handleClear();
    }
};

```

```js
<div
  className="calculator"
  tabIndex="0"
  onKeyDown={handleKeyDown}
  style={{ outline: 'none' }}
>

```

* `tabIndex="0"` ➔ permet de rendre la div focusable.

* `style={{ outline: 'none' }}` ➔ pour éviter le contour bleu moche quand on clique dessus.

🛑🛑🛑🛑 Euh je sais pas pour vous mais mon code ne marche pas 🛑🛑🛑🛑

```
le problème qui se pose actuellement est dû au fait qu'aussi longtemps que nous n'avons pas cliqué sur un élément de la `div`, elle n'est pas focus et on ne capte donc pas le `onKeyDown`.
```


#### 🚑 Correction propre : focus automatique sur la calculatrice

Pour resoudre notre problème, nous allons voir deux `hook` que React met à notre disposition : `useRef` et `useEffect`.

* `useRef`

`useRef` est un `hook` très puissant de React qui permet de créer des références persistantes à des éléments DOM ou à des valeurs. Contrairement à `useState`, **les références ne déclenchent pas de re-rendu** de ton composant lorsqu'elles sont mises à jour. Cela les rend très utiles pour les cas où tu veux manipuler un élément DOM directement ou garder une valeur qui persiste sans provoquer un nouveau rendu.

* Utilisations principales de `useRef`
  1. Accéder à un élément DOM directement

  2. Conserver une valeur mutable qui persiste entre les rendus

  3. Utilisation des `refs` pour les animations ou les API externes

* Syntaxe de base

```js
const maRef = useRef(valeurInitiale);
```

* `maRef.current` contient la valeur stockée
* Tu peux lire ou modifier `maRef.current` sans re-render

* Différence avec useState

| useState                           | useRef                             |
| ---------------------------------- | ---------------------------------- |
| Provoque un re-render              | Ne provoque pas de re-render       |
| Utilisé pour afficher des valeurs  | Utilisé pour stocker ou référencer |
| React suit la valeur pour le rendu | React l’ignore pendant le rendu    |

* Mise en pratique avec notre calculatrice 

##### a. Créer une référence avec `useRef`

```js
const calculatorRef = React.useRef(null);
```

##### b. Applique la `ref` sur ta `<div>`

```js
<div
  ref={calculatorRef}
  className="calculator"
  tabIndex="0"
  onKeyDown={handleKeyDown}
  style={{ outline: 'none' }}
>
//...
</div>
```

* `useEffect`

`useEffect` est **un hook de gestion des effets de bord** (side effects) en React.
➔ Un effet de bord, **c’est tout ce qui se passe en dehors du cycle normal de rendu** du composant.

Exemples d'effets de bord :

* Modifier le DOM manuellement

* Appeler une API

* Ajouter des écouteurs d’événements (keyboard, scroll, etc.)

* Démarrer / Arrêter un timer

##### a. Syntaxe de base

```js
import React, { useEffect } from 'react';

useEffect(() => {
  // Code exécuté après chaque rendu du composant
});

```
`useEffect` prend **une fonction** qui sera appelée **après** le rendu du composant.

##### b. Les 3 grandes façons d'utiliser useEffect


###### b. 1) Sans dépendances ➔ useEffect(() => { })

```jsx
useEffect(() => {
  console.log('Le composant a été rendu ou mis à jour');
});
```

* S’exécute **après chaque rendu** du composant.

* Attention : même après **chaque modification d’état** ou de **props**.


###### b. 2) Avec dépendances vides ➔ useEffect(() => { }, [])

```jsx
useEffect(() => {
  console.log('Le composant a été monté');
}, []);

```
* S’exécute **1 seule fois**, après le **montage** (comme componentDidMount en class component).

* Très utile pour :

  * Focus auto

  * Appel API initial

  * Écouteur d'événements global



###### b. 3) Avec dépendances spécifiques ➔ useEffect(() => { }, [variable])

```jsx
useEffect(() => {
  console.log('La variable X a changé');
}, [x]);

```

* S’exécute **seulement** quand `x` change de valeur.

* Plusieurs dépendances possibles :

```jsx
useEffect(() => {
  console.log('X ou Y a changé');
}, [x, y]);

```

* Réglons maintenant le problème avec notre calculatrice

```jsx
const calculatorRef = React.useRef();

useEffect(() => {
  calculatorRef.current.focus();
}, []);

```

* Cycle de vie d'un composant en React
Quand tu écris un composant React, il passe par plusieurs étapes (comme un être vivant : naissance → croissance → mort).

Chaque composant React a un cycle de vie qui est composé de **3 grandes phases** :

| Phases principales         | Description rapide                                                      |
| -------------------------- | ----------------------------------------------------------------------- |
| **Montage (Mounting)**     | Le composant est créé et inséré dans le DOM.                            |
| **Mise à jour (Updating)** | Le composant est mis à jour suite à un changement de props ou de state. |
| **Démontage (Unmounting)** | Le composant est retiré du DOM.                                         |

   * lien entre cycle de vie d'un composant et le `hook` `useEffect`

1️⃣ Phase de Montage (Mounting)

C'est la création du composant : il est construit, inséré dans le DOM, et rendu visible à l'écran.

**Avec Hooks** :

   * `useEffect(() => { ... }, [])` s'exécute après le premier rendu.

2️⃣ Phase de Mise à jour (Updating)
Quand l'état (`state`) ou les propriétés (`props`) du composant changent, **il se met à jour**. Cela déclenche une **ré-exécution du rendu**.

**Avec Hooks** :

   * `useEffect(() => { ... }, [dépendances])` s'exécute à chaque changement d'une dépendance.

3️⃣ Phase de Démontage (Unmounting)
Quand le composant **est supprimé du DOM**, React te donne une opportunité de **nettoyer** tout ce que tu as mis en place :

   * timers,

   * abonnements WebSocket,

   * écouteurs d'événements,

   * etc.

**Avec Hooks** :

   * `useEffect(() => { return () => { ... } }, [])`



##### 3. Nettoyer les effets : `return` dans `useEffect`

* Objectif :
Montrer **clairement** que **sans fonction de nettoyage**, des **problèmes** peuvent apparaître, comme :

   * des **écouteurs d'événements** qui restent actifs,

   * des **compteurs** qui doublent,

   * ou **des fuites de mémoire**.


###### 3. 1) Ajoutons un compteur avec `setInterval` dans ta calculatrice

```jsx
const [count, setCount] = useState(0);
```

###### 3. 2) Projetons à l'écran la variable `count` pour observer ce qui se passera au rendu de notre composant

```jsx 
<p>{count}</p>
```

###### 3. 3) Ajoutons un `useEffect` qui démarre un `setInterval`

```jsx 
React.useEffect(() => {
    console.log('Nouveau timer lancé');

    const interval = setInterval(() => {
      console.log('Tick');
      setCount((prevCount) => prevCount + 1);
    }, 1000);

   
  }, []); // [] : se lance une fois au montage
```

⚠️ Que se passe-t-il ?

   * À CHAQUE MONTAGE, **un NOUVEAU intervalle est créé**.

   * **Les anciens intervals NE SONT PAS supprimés**.

   * Résultat horrible :
    
      ➔ Ton compteur commence à **s'incrémenter de plus en plus vite** au fur et à mesure que tu montes/démontes ton composant.

      ➔ Cela crée une fuite de mémoire.

Il faut donc ajouter une fonction de néttoyage pour être sûr de partir sur des bases propres avec le `setInterval` à chaque rendu du composant.

```jsx 
React.useEffect(() => {

    //ajout de code
    return () => {
      console.log('Nettoyage du timer');
      clearInterval(interval);
    };
   
  }, []); // [] : se lance une fois au montage
```

### NB : N’utilisez les Hooks qu’au niveau supérieur des composants

✅ Les Hooks doivent être appelés directement dans le corps du composant.
PAS dans une boucle, une condition, ou une fonction imbriquée.

❌ Mauvais :
```jsx
if (isEnabled) {
  const [count, setCount] = useState(0); // ❌ PAS DANS UNE CONDITION !
}

```

✅ Bon :

```jsx
const [count, setCount] = useState(0);
if (isEnabled) {
  // logiques normales ici
}
```
```
Pourquoi ?
React doit pouvoir savoir dans quel ordre les Hooks sont appelés à chaque rendu. Sinon, il ne peut pas suivre correctement leur état.
```
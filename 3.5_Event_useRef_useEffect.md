## Les √©v√©nements en React

En React, **les √©v√©nements** sont des actions d√©clench√©es par l‚Äôutilisateur ou le navigateur (comme un clic, une saisie clavier, un survol de souris, etc.). React g√®re les √©v√©nements d'une mani√®re similaire au DOM classique, mais avec quelques diff√©rences : par exemple, les noms des √©v√©nements sont en **camelCase** (`onClick` au lieu de `onclick`), et au lieu de passer une cha√Æne de caract√®res, on passe une **fonction** comme gestionnaire.

Nous allons customiser notre calculatrice pour d√©couvrir les √©v√©nements.

## √âtape 1 : Comprendre et am√©liorer `onClick`

### Ce qu'on fait
* Tu utilises d√©j√† `onClick` sur chaque bouton dans ta calculatrice.
* Chaque bouton appelle une fonction diff√©rente (`handleNumberClick`, `handleOperatorClick`, etc.).

### Instructions Pratiques

Dans ton fichier `Calculator.jsx`, fais ceci :

#### 1. Modifie `handleNumberClick`

```js
const handleNumberClick = (value) => {
    console.log(`Chiffre cliqu√© : ${value}`);
    //...
};
```

#### 2. Modifie `handleOperatorClick`

```js
const handleOperatorClick = (value) => {
    console.log(`Op√©rateur cliqu√© : ${value}`);
    //...
};
```

#### 3. Modifie `handleClear`

```js
const handleClear = () => {
    console.log("Calcul effac√© !");
    //...
};
```

#### 4. Modifie `handleEqualClick`

```js
const handleEqualClick = () => {
    console.log("Calcul effectu√© !");
    //...
};
```

---

## √âtape 2 ‚Äî `onMouseEnter` et `onMouseLeave`

### Ce qu'on fait
* On veut ajouter un effet visuel quand on passe la souris sur un bouton.
* Pour cela, on utilise deux √©v√©nements React :
   * `onMouseEnter` ‚ûî la souris entre dans le bouton.
   * `onMouseLeave` ‚ûî la souris sort du bouton.

### Instructions Pratiques

Dans `Button.jsx`, ajoute :

```js
import React from 'react';

export default function Button({ onClick, label }) {
    const [hover, setHover] = React.useState(false);

    return (
        <button
            onClick={() => onClick(label)}
            onMouseEnter={() => setHover(true)}
            onMouseLeave={() => setHover(false)}
            style={{
                backgroundColor: hover ? '#e0e0e0' : 'white',
                border: '1px solid #ccc',
                padding: '10px',
                margin: '5px',
                width: '40px',
                cursor: 'pointer',
                transition: 'background-color 0.3s',
            }}
        >
            {label}
        </button>
    );
}
```

---

## √âtape 3 ‚Äî Ajouter le support clavier (`onKeyDown`)

### Ce qu'on fait
* **Jusqu‚Äôici**, tu cliquais avec la souris sur les boutons.
* **Maintenant**, on va pouvoir **utiliser le clavier** pour entrer les chiffres et les op√©rateurs.

### Instructions Pratiques

Dans `Calculator.jsx`, ajoute :

#### 1. Ajouter `onKeyDown`

```js
const handleKeyDown = (event) => {
    const key  = event.key;
    console.log(`Touche press√©e : ${key}`);

    if (['/', '*', '-', '+', 'Enter', '=', 'c', 'C'].includes(key) || !isNaN(Number(key))) {
        event.preventDefault(); // Emp√™cher les comportements par d√©faut du navigateur
    }

    if (!isNaN(key)) {
        handleNumberClick(key);
    } else if (['+', '-', '*', '/'].includes(key)) {
        handleOperatorClick(key);
    } else if (key === 'Enter') {
        handleEqualClick();
    } else if (key === 'c' || key === 'C') {
        handleClear();
    }
};
```

#### 2. Attacher l'√©v√©nement √† la `div`

```js
<div
  className="calculator"
  tabIndex="0"
  onKeyDown={handleKeyDown}
  style={{ outline: 'none' }}
>
```

* `tabIndex="0"` ‚ûî Rend la div focusable.
* `style={{ outline: 'none' }}` ‚ûî √âvite le contour bleu moche quand on clique dessus.

üõë **Probl√®me** : La div n'est pas focus tant qu'on n'a pas cliqu√© dessus, donc on ne capte pas `onKeyDown`.

---

### üöë Correction : Focus automatique sur la calculatrice

Pour r√©soudre ce probl√®me, utilisons deux hooks : `useRef` et `useEffect`.

#### 1. Cr√©er une r√©f√©rence avec `useRef`

```js
const calculatorRef = React.useRef(null);
```

#### 2. Appliquer la `ref` sur ta `<div>`

```js
<div
  ref={calculatorRef}
  className="calculator"
  tabIndex="0"
  onKeyDown={handleKeyDown}
  style={{ outline: 'none' }}
>
```

#### 3. Utiliser `useEffect` pour le focus

```js
React.useEffect(() => {
  calculatorRef.current.focus();
}, []);
```

---

### Cycle de vie d'un composant en React

Quand tu √©cris un composant React, il passe par plusieurs √©tapes :

| Phases principales         | Description rapide                                                      |
| -------------------------- | ----------------------------------------------------------------------- |
| **Montage (Mounting)**     | Le composant est cr√©√© et ins√©r√© dans le DOM.                            |
| **Mise √† jour (Updating)** | Le composant est mis √† jour suite √† un changement de props ou de state. |
| **D√©montage (Unmounting)** | Le composant est retir√© du DOM.                                         |

#### Utilisation de `useEffect`

1. **Montage** : `useEffect(() => { ... }, [])` s'ex√©cute apr√®s le premier rendu.
2. **Mise √† jour** : `useEffect(() => { ... }, [d√©pendances])` s'ex√©cute √† chaque changement d'une d√©pendance.
3. **D√©montage** : `useEffect(() => { return () => { ... } }, [])`.

---

### Nettoyer les effets : `return` dans `useEffect`

Pour √©viter des probl√®mes comme des √©couteurs d'√©v√©nements qui restent actifs, ajoutons une fonction de nettoyage.

### Exemple avec `setInterval`

1. **Ajout d'un compteur** :

```jsx
const [count, setCount] = useState(0);
```

2. **Afficher le compteur** :

```jsx 
<p>{count}</p>
```

3. **D√©marrer un intervalle** :

```jsx 
React.useEffect(() => {
  const interval = setInterval(() => {
    setCount((prevCount) => prevCount + 1);
  }, 1000);

  return () => {
    clearInterval(interval); // Nettoyage
  };
}, []);
```

---

### NB : N‚Äôutilisez les Hooks qu‚Äôau niveau sup√©rieur des composants

‚úÖ Les Hooks doivent √™tre appel√©s directement dans le corps du composant, **PAS dans une boucle, une condition, ou une fonction imbriqu√©e**.

```jsx
const [count, setCount] = useState(0);
if (isEnabled) {
  // logiques normales ici
}
```

Pourquoi ? React doit savoir dans quel ordre les Hooks sont appel√©s √† chaque rendu pour suivre correctement leur √©tat.
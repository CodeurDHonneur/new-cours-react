En React, **les Ã©vÃ©nements** sont des actions dÃ©clenchÃ©es par lâ€™utilisateur ou le navigateur (comme un clic, une saisie clavier, un survol de souris, etc.). React gÃ¨re les Ã©vÃ©nements d'une maniÃ¨re similaire au DOM classique, mais avec quelques diffÃ©rences : par exemple, les noms des Ã©vÃ©nements sont en **camelCase** (`onClick` au lieu de `onclick`), et au lieu de passer une chaÃ®ne de caractÃ¨res, on passe une **fonction** comme gestionnaire.

Nous allons customiser notre calculatrice dans le but de dÃ©couvrir les Ã©vÃ©nements.

## Ã‰tape 1 : Comprendre et amÃ©liorer `onClick`

### Ce qu'on fait
* Tu utilises dÃ©jÃ  `onClick` sur chaque bouton dans ta calculatrice.

* Chaque bouton appelle une fonction diffÃ©rente (`handleNumberClick`, `handleOperatorClick`, etc.)

* Nous allons :

  * **Ajouter des** `console.log` dans chaque fonction

  * **Voir ce qui se passe dans la console** Ã  chaque clic

  * **Mieux comprendre comment l'Ã©vÃ©nement fonctionne**

### Instructions Pratiques
Dans ton fichier `Calculator.jsx`, fais ceci :

##### 1. Modifie `handleNumberClick`

```js
const handleNumberClick = (value) => {
    console.log(`Chiffre cliquÃ© : ${value}`);
    //...
};
```

##### 2. Modifie `handleOperatorClick`

```js
const handleOperatorClick = (value) => {
    console.log(`OpÃ©rateur cliquÃ© : ${value}`);
    //...
};
```
##### 3. Modifie `handleClear`

```js
const handleClear = () => {
    console.log("Calcul effacÃ© !");
    //...
};
```

##### 4. Modifie `handleEqualClick`

```js
const handleEqualClick = () => {
    console.log("Calcul effectuÃ© !");
   //...
};
```

## Ã‰tape 2 â€” `onMouseEnter` et `onMouseLeave`

### Ce qu'on fait
* On veut ajouter un effet visuel quand on passe la souris sur un bouton.

* Pour Ã§a, on utilise deux Ã©vÃ©nements React :

   * `onMouseEnter` â” la souris entre dans le bouton.

   * `onMouseLeave` â” la souris sort du bouton.

L'objectif est d'**apprendre Ã  utiliser ces deux Ã©vÃ©nements** et de rendre la calculatrice **plus interactive** !

### Instructions Pratiques
On va modifier  `Button.jsx`.

On ajoute :

* Un **Ã©tat** pour savoir si la souris est sur le bouton (`hover`)

* Des **Ã©vÃ©nements** `onMouseEnter` et `onMouseLeave`

* Un **style dynamique** qui change en fonction de hover

```js
import React from 'react';

export default function Button({ onClick, label }) {
    const [hover, setHover] = React.useState(false);

    return (
        <button
            onClick={() => onClick(label)}
            onMouseEnter={() => setHover(true)}
            onMouseLeave={() => setHover(false)}
            style={{
                backgroundColor: hover ? '#e0e0e0' : 'white',
                border: '1px solid #ccc',
                padding: '10px',
                margin: '5px',
                width: '40px',
                cursor: 'pointer',
                transition: 'background-color 0.3s',
            }}
        >
            {label}
        </button>
    );
}

```

## Ã‰tape 3 â€” Ajouter le support clavier (`onKeyDown`)

### Ce qu'on fait
* **Jusquâ€™ici** tu cliquais avec la souris sur les boutons.

* **Maintenant** on va pouvoir **utiliser le clavier** pour entrer les chiffres et les opÃ©rateurs.

Pour Ã§a, on va utiliser l'Ã©vÃ©nement `onKeyDown` â” dÃ©tecter quand une touche du clavier est pressÃ©e.

### Instructions Pratiques
On va ajouter un gestionnaire dâ€™Ã©vÃ©nements sur la `div` principale du composant `Calculator`.

#### 1. Ajouter `onKeyDown` dans Calculator
Dans le fichier `Calculator.jsx`, commenÃ§ons par :

1. Ajouter une fonction qui va Ã©couter les touches du clavier

2. L'attacher Ã  ton composant `div` principale

3. Penser Ã  ajouter `tabIndex` sur la `div` pour quâ€™elle soit **focusable** (sinon React n'Ã©coutera pas les Ã©vÃ©nements clavier).

```js
const handleKeyDown = (event) => {
    const key  = event.key;
    console.log(`Touche pressÃ©e : ${key}`);

    if (['/', '*', '-', '+', 'Enter', '=', 'c', 'C'].includes(key) || !isNaN(Number(key))) {
        event.preventDefault(); // empÃªcher les comportements par dÃ©fauts du navigateur
    }

    if (!isNaN(key)) {
        // Si c'est un chiffre
        handleNumberClick(key);
    } else if (['+', '-', '*', '/'].includes(key)) {
        // Si c'est un opÃ©rateur
        handleOperatorClick(key);
    } else if (key === 'Enter') {
        // Si c'est EntrÃ©e
        handleEqualClick();
    } else if (key === 'c' || key === 'C') {
        // Si c'est C ou c
        handleClear();
    }
};

```

```js
<div
  className="calculator"
  tabIndex="0"
  onKeyDown={handleKeyDown}
  style={{ outline: 'none' }}
>

```

* `tabIndex="0"` â” permet de rendre la div focusable.

* `style={{ outline: 'none' }}` â” pour Ã©viter le contour bleu moche quand on clique dessus.

ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ Euh je sais pas pour vous mais mon code ne marche pas ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘

```
le problÃ¨me qui se pose actuellement est dÃ» au fait qu'aussi longtemps que nous n'avons pas cliquÃ© sur un Ã©lÃ©ment de la `div`, elle n'est pas focus et on ne capte donc pas le `onKeyDown`.
```


#### ğŸš‘ Correction propre : focus automatique sur la calculatrice

Pour resoudre notre problÃ¨me, nous allons voir deux `hook` que React met Ã  notre disposition : `useRef` et `useEffect`.

* `useRef`

`useRef` est un `hook` trÃ¨s puissant de React qui permet de crÃ©er des rÃ©fÃ©rences persistantes Ã  des Ã©lÃ©ments DOM ou Ã  des valeurs. Contrairement Ã  `useState`, **les rÃ©fÃ©rences ne dÃ©clenchent pas de re-rendu** de ton composant lorsqu'elles sont mises Ã  jour. Cela les rend trÃ¨s utiles pour les cas oÃ¹ tu veux manipuler un Ã©lÃ©ment DOM directement ou garder une valeur qui persiste sans provoquer un nouveau rendu.

* Utilisations principales de `useRef`
  1. AccÃ©der Ã  un Ã©lÃ©ment DOM directement

  2. Conserver une valeur mutable qui persiste entre les rendus

  3. Utilisation des `refs` pour les animations ou les API externes

* Syntaxe de base

```js
const maRef = useRef(valeurInitiale);
```

* `maRef.current` contient la valeur stockÃ©e
* Tu peux lire ou modifier `maRef.current` sans re-render

* DiffÃ©rence avec useState

| useState                           | useRef                             |
| ---------------------------------- | ---------------------------------- |
| Provoque un re-render              | Ne provoque pas de re-render       |
| UtilisÃ© pour afficher des valeurs  | UtilisÃ© pour stocker ou rÃ©fÃ©rencer |
| React suit la valeur pour le rendu | React lâ€™ignore pendant le rendu    |

* Mise en pratique avec notre calculatrice 

##### a. CrÃ©er une rÃ©fÃ©rence avec `useRef`

```js
const calculatorRef = React.useRef(null);
```

##### b. Applique la `ref` sur ta `<div>`

```js
<div
  ref={calculatorRef}
  className="calculator"
  tabIndex="0"
  onKeyDown={handleKeyDown}
  style={{ outline: 'none' }}
>
//...
</div>
```

* `useEffect`

`useEffect` est **un hook de gestion des effets de bord** (side effects) en React.
â” Un effet de bord, **câ€™est tout ce qui se passe en dehors du cycle normal de rendu** du composant.

Exemples d'effets de bord :

* Modifier le DOM manuellement

* Appeler une API

* Ajouter des Ã©couteurs dâ€™Ã©vÃ©nements (keyboard, scroll, etc.)

* DÃ©marrer / ArrÃªter un timer

##### a. Syntaxe de base

```js
import React, { useEffect } from 'react';

useEffect(() => {
  // Code exÃ©cutÃ© aprÃ¨s chaque rendu du composant
});

```
`useEffect` prend **une fonction** qui sera appelÃ©e **aprÃ¨s** le rendu du composant.

##### b. Les 3 grandes faÃ§ons d'utiliser useEffect


###### b. 1) Sans dÃ©pendances â” useEffect(() => { })

```jsx
useEffect(() => {
  console.log('Le composant a Ã©tÃ© rendu ou mis Ã  jour');
});
```

* Sâ€™exÃ©cute **aprÃ¨s chaque rendu** du composant.

* Attention : mÃªme aprÃ¨s **chaque modification dâ€™Ã©tat** ou de **props**.


###### b. 2) Avec dÃ©pendances vides â” useEffect(() => { }, [])

```jsx
useEffect(() => {
  console.log('Le composant a Ã©tÃ© montÃ©');
}, []);

```
* Sâ€™exÃ©cute **1 seule fois**, aprÃ¨s le **montage** (comme componentDidMount en class component).

* TrÃ¨s utile pour :

  * Focus auto

  * Appel API initial

  * Ã‰couteur d'Ã©vÃ©nements global



###### b. 3) Avec dÃ©pendances spÃ©cifiques â” useEffect(() => { }, [variable])

```jsx
useEffect(() => {
  console.log('La variable X a changÃ©');
}, [x]);

```

* Sâ€™exÃ©cute **seulement** quand `x` change de valeur.

* Plusieurs dÃ©pendances possibles :

```jsx
useEffect(() => {
  console.log('X ou Y a changÃ©');
}, [x, y]);

```

* RÃ©glons maintenant le problÃ¨me avec notre calculatrice

```jsx
const calculatorRef = React.useRef();

useEffect(() => {
  calculatorRef.current.focus();
}, []);

```

* Cycle de vie d'un composant en React
Quand tu Ã©cris un composant React, il passe par plusieurs Ã©tapes (comme un Ãªtre vivant : naissance â†’ croissance â†’ mort).

Chaque composant React a un cycle de vie qui est composÃ© de **3 grandes phases** :

| Phases principales         | Description rapide                                                      |
| -------------------------- | ----------------------------------------------------------------------- |
| **Montage (Mounting)**     | Le composant est crÃ©Ã© et insÃ©rÃ© dans le DOM.                            |
| **Mise Ã  jour (Updating)** | Le composant est mis Ã  jour suite Ã  un changement de props ou de state. |
| **DÃ©montage (Unmounting)** | Le composant est retirÃ© du DOM.                                         |

   * lien entre cycle de vie d'un composant et le `hook` `useEffect`

1ï¸âƒ£ Phase de Montage (Mounting)

C'est la crÃ©ation du composant : il est construit, insÃ©rÃ© dans le DOM, et rendu visible Ã  l'Ã©cran.

**Avec Hooks** :

   * `useEffect(() => { ... }, [])` s'exÃ©cute aprÃ¨s le premier rendu.

2ï¸âƒ£ Phase de Mise Ã  jour (Updating)
Quand l'Ã©tat (`state`) ou les propriÃ©tÃ©s (`props`) du composant changent, **il se met Ã  jour**. Cela dÃ©clenche une **rÃ©-exÃ©cution du rendu**.

**Avec Hooks** :

   * `useEffect(() => { ... }, [dÃ©pendances])` s'exÃ©cute Ã  chaque changement d'une dÃ©pendance.

3ï¸âƒ£ Phase de DÃ©montage (Unmounting)
Quand le composant **est supprimÃ© du DOM**, React te donne une opportunitÃ© de **nettoyer** tout ce que tu as mis en place :

   * timers,

   * abonnements WebSocket,

   * Ã©couteurs d'Ã©vÃ©nements,

   * etc.

**Avec Hooks** :

   * `useEffect(() => { return () => { ... } }, [])`



##### 3. Nettoyer les effets : `return` dans `useEffect`

* Objectif :
Montrer **clairement** que **sans fonction de nettoyage**, des **problÃ¨mes** peuvent apparaÃ®tre, comme :

   * des **Ã©couteurs d'Ã©vÃ©nements** qui restent actifs,

   * des **compteurs** qui doublent,

   * ou **des fuites de mÃ©moire**.


###### 3. 1) Ajoutons un compteur avec `setInterval` dans ta calculatrice

```jsx
const [count, setCount] = useState(0);
```

###### 3. 2) Projetons Ã  l'Ã©cran la variable `count` pour observer ce qui se passera au rendu de notre composant

```jsx 
<p>{count}</p>
```

###### 3. 3) Ajoutons un `useEffect` qui dÃ©marre un `setInterval`

```jsx 
React.useEffect(() => {
    console.log('Nouveau timer lancÃ©');

    const interval = setInterval(() => {
      console.log('Tick');
      setCount((prevCount) => prevCount + 1);
    }, 1000);

   
  }, []); // [] : se lance une fois au montage
```

âš ï¸ Que se passe-t-il ?

   * Ã€ CHAQUE MONTAGE, **un NOUVEAU intervalle est crÃ©Ã©**.

   * **Les anciens intervals NE SONT PAS supprimÃ©s**.

   * RÃ©sultat horrible :
    
      â” Ton compteur commence Ã  **s'incrÃ©menter de plus en plus vite** au fur et Ã  mesure que tu montes/dÃ©montes ton composant.

      â” Cela crÃ©e une fuite de mÃ©moire.

Il faut donc ajouter une fonction de nÃ©ttoyage pour Ãªtre sÃ»r de partir sur des bases propres avec le `setInterval` Ã  chaque rendu du composant.

```jsx 
React.useEffect(() => {

    //ajout de code
    return () => {
      console.log('Nettoyage du timer');
      clearInterval(interval);
    };
   
  }, []); // [] : se lance une fois au montage
```

### NB : Nâ€™utilisez les Hooks quâ€™au niveau supÃ©rieur des composants

âœ… Les Hooks doivent Ãªtre appelÃ©s directement dans le corps du composant.
PAS dans une boucle, une condition, ou une fonction imbriquÃ©e.

âŒ Mauvais :
```jsx
if (isEnabled) {
  const [count, setCount] = useState(0); // âŒ PAS DANS UNE CONDITION !
}

```

âœ… Bon :

```jsx
const [count, setCount] = useState(0);
if (isEnabled) {
  // logiques normales ici
}
```
```
Pourquoi ?
React doit pouvoir savoir dans quel ordre les Hooks sont appelÃ©s Ã  chaque rendu. Sinon, il ne peut pas suivre correctement leur Ã©tat.
```
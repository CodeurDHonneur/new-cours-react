### Qu'est-ce qu'un effet secondaire ?

Un effet secondaire se produit chaque fois qu'une fonction affecte des parties du programme qui ne sont pas strictement li√©es √† sa t√¢che principale. 

**Exemple :** 
```js
let total = 0;

function addToTotal(amount) {
  total += amount;
  console.log(`Total: ${total}`);
}
```

### Pourquoi √©viter les effets secondaires ?

##### 1. Pr√©visibilit√© et simplicit√©
Une fonction sans effet secondaire est simple √† comprendre. En passant une entr√©e donn√©e, on obtient toujours le m√™me r√©sultat sans se soucier de l'impact sur d'autres parties du programme. Le code est pr√©visible et r√©duit ainsi les surprises.

##### 2. D√©bogage plus facile
Dans le cas o√π on aurait une variable globale avec une valeur incorrecte manipul√©e par plusieurs fonctions avec des effets secondaires, retrouver l'origine du bug peut s'av√©rer un v√©ritable casse-t√™te.

##### 3. Tests simplifi√©s
Tester une fonction avec des effets secondaires est compliqu√©. Aucun test ne pourra se faire sans la prise en compte de l'impact qu'elle a sur le reste du code.

### Comment √©viter les effets secondaires ?
Le principe est simple : **les fonctions doivent √™tre pures**.

**Exemple :** 
```js
const add = (x, y) => {
    return x + y;
}

console.log(add(1, 2));
```
Une fonction pure est une fonction qui, pour un ensemble d‚Äôentr√©es donn√©es, retourne **toujours le m√™me r√©sultat** **sans modifier l'√©tat** global du programme.

### Mauvaise pratique en programmation : 

```js
function incrementAge(person) {
  person.age++;
}
```

Par la modification de l'objet pass√© en argument, on introduit un effet secondaire subtil. La bonne pratique est de retourner une nouvelle instance de l'objet avec la valeur modifi√©e, au lieu de changer l'objet d'origine.

```js
function incrementAge(person) {
  return { age: person.age + 1 };
}
```

### Autre exemple avec un tableau : 

```js
const movies = [];

const addMovie = (movie) => {
    return movies.push(movie);
}

addMovie("film 1");

console.log("movies", movies);
```

Ici, `addMovie` est une fonction `impure` parce qu'elle modifie la valeur globale `movies`. La bonne pratique serait de faire comme suit : 

```js
const movies = [];

// Ainsi notre fonction reste pure quoi qu'il arrive
const addMovie = (movie, movies) => {
  return movies.concat(movie); // Utilisation de concat pour cr√©er un nouveau tableau
}

movies = addMovie("film 1", movies);
```

On ne se mentira pas, il existe des cas o√π des effets secondaires sont in√©vitables, comme l'√©criture dans une base de donn√©es ou l'appel √† une API. N√©anmoins, travaillons √† √©crire du code propre en suivant au maximum cette r√®gle.

### Exercices de compr√©hension

üìå **Exemple tr√®s simple**

**Exo 1**
```js
let tauxTVA = 0.2;

function ajouterTVA(prix) {
  return prix + prix * tauxTVA;
}
```

**Exo 2**
```js
function doublerElements(tab) {
  for (let i = 0; i < tab.length; i++) {
    tab[i] *= 2;
  }
  return tab;
}
```

üü° **Interm√©diaire**

**Exo 3** 
```js
function tirerNumero() {
  return Math.floor(Math.random() * 100);
}
```

**Exo 4** 
```js
let utilisateur = { nom: "Sarah", age: 29 };

function anniversaire() {
  utilisateur.age += 1;
  console.log(`Bon anniversaire ${utilisateur.nom} ! Tu as ${utilisateur.age} ans.`);
}
```

Exemples de composant pur et impur en React

```jsx
// ‚ùå Composant impur (√† √©viter)
let counter = 0;

const ImpureComponent = () => {
  counter++;
  return <div>Rendu {counter}</div>;
};

// ‚úÖ Composant pur
const PureComponent = ({ count }) => {
  return <div>Rendu {count}</div>;
};
```
## üö® Effets Secondaires Courants √† √âviter

| Type d'Effet Secondaire  | Exemple Impur ‚ùå | Version Pure ‚úÖ | Pourquoi ? |
|--------------------------|----------------|----------------|------------|
| **Modification de variables globales** | ` let count = 0; function increment() {  count++;}` | `function increment(count) {  return count + 1;}` | √âvite les d√©pendances cach√©es |
| **Mutation d'objets/tableaux** | `function updateUser(user) {  user.age++;  return user;}` | `function updateUser(user) {  return { ...user, age: user.age + 1 };}` | Garantit l'immutabilit√© |
| **Appels API/IO impurs** | `function fetchData() {  return fetch('/api').then(res => {    document.title = "Done"; // Effet secondaire    return res.json();  });}` | `function fetchData() {  return fetch('/api')    .then(res => res.json());}// G√©rer le titre dans useEffect` | S√©paration des responsabilit√©s |
| **Manipulation du DOM directe** | `function renderMessage(msg) {  document.getElementById('msg').innerText = msg;}` | `// React g√®re le DOM via le stateconst [message, setMessage] = useState('');return <div id="msg">{message}</div>;` | √âvite les conflits avec le Virtual DOM |
| **Logging/Timers** | `function calculate(x) {  console.log('Calculating...');  return x * 2;}` | `function calculate(x) {  return x * 2;}// Logging externe si n√©cessaire` | Garde la fonction d√©terministe |




